)
# Calculate the cophenetic distance for the single linkage clustering.
SingLin.dist <- cophenetic(Hclus.1)
# Print the object class of the cophenetic distance
class(SingLin.dist)
CompLin.dist <- cophenetic(Hclus.2)
# Print the object class of the cophenetic distance
class(CompLin.dist)
UPGMA.dist <- cophenetic(Hclus.3)
# Print the object class of the cophenetic distance
class(UPGMA.dist)
Ward.dist <- cophenetic(Hclus.4)
# Print the object class of the cophenetic distance
class(Ward.dist)
## Plot the original vs cophenetic for the Single Linkage dendrogram.
plot(x = SingLin.dist, # Cophenetic distances.
y = macnally.dist, # Original distances.
main = 'Cophenetic Correlation\n Single linkage',# Figure main title.
pch = 19, col = "lightgrey", cex=1.2 # Define Point type, colour, and size arguments.
)
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
lty = 1, lwd = 2,
xpd = F) # Define the line width and type attributes.
SmothMod <- lowess(macnally.dist ~ SingLin.dist)
lines(SmothMod, # The Loess model
lty = 2, col = "red", lwd = 2) # Define the line colour, width, and type attributes.
cor.SingLin <- cor(SingLin.dist, macnally.dist)
# Add the correlation to the figure as a text box
legend("topleft", # Position the legend?
legend = paste("Pearson = ", round(cor.SingLin, 3)), # Legend Text.
bty = "n" # Type of box to be drawn around the legend.
)
Gower distance for the Single linkage clustering
macnally.dist
SingLin.dist
gow.dist.single <- sum((macnally.dist - SingLin.dist) ^ 2)
gow.dist.single
gow.dist.comp <- sum((macnally.dist - CompLin.dist) ^ 2)
gow.dist.comp
gow.dist.UPGMA <- sum((macnally.dist - UPGMA.dist) ^ 2)
gow.dist.UPGMA
gow.dist.ward <- sum((macnally.dist - Ward.dist) ^ 2)
gow.dist.ward
# Cut the best model into two (2) groups.
TwoGroups <- cutree(tree = Hclus.3, # A tree as produced by hclust.
k = 2 # Desired number of groups.
)
TwoGroups
ThreeGroups <- cutree(tree = Hclus.3, # A tree as produced by hclust.
k = 3 # Desired number of groups.
)
ThreeGroups
FourGroups <- cutree(tree = Hclus.3, # A tree as produced by hclust.
k = 4 # Desired number of groups.
)
FourGroups
FiveGroups <- cutree(tree = Hclus.3, # A tree as produced by hclust.
k = 5 # Desired number of groups.
)
FiveGroups
plot(x = Hclus.3, # An object of the type produced by hclust.
labels = cutree(Hclus.3, 2), # A character vector of labels for the tree's leaves.
main = "Two groups\n UPGMA", # Main title.
cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
)
plot(x = Hclus.3, # An object of the type produced by hclust.
labels = cutree(Hclus.3, 3), # A character vector of labels for the tree's leaves.
main = "Three groups\n UPGMA", # Main title.
cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
)
plot(x = Hclus.3, # An object of the type produced by hclust.
labels = cutree(Hclus.3, 4), # A character vector of labels for the tree's leaves.
main = "Four groups\n UPGMA", # Main title.
cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
)
plot(x = Hclus.3, # An object of the type produced by hclust.
labels = cutree(Hclus.3, 5), # A character vector of labels for the tree's leaves.
main = "Five groups\n UPGMA", # Main title.
cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
)
plot(x = Hclus.3$height, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.
y = nrow(macnally):2, # Fusion Node.
type = "S", # type of plot desired? = stair steps.
main = "Fusion levels - UPGMA", # Main title.
ylab = "k (number of clusters)", # Y-lab label.
xlab = "h (node height)", # x-lab label.
col = "grey", lwd = 2 # Line piloting arguments.
)
text(x = Hclus.3$height, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.
y = nrow(macnally):2, # Fusion Node.
labels = nrow(macnally):2, # Fusion Node.
col = "red", cex = 0.8 # Text colour and size?
)
classification as labels.
plot(x = Hclus.3, # An object of the type produced by hclust.
labels = cutree(Hclus.3, 4), # A character vector of labels for the tree's leaves.
main = "Four groups\n UPGMA", # Main title.
cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
)
# Choose the number of clusters
k <- 6
# Prune the UPGMA tree into six groups
UPGMA.6groups <- cutree(tree = Hclus.3, # A tree as produced by hclust.
k = k # Desired number of groups.
)
# Compute silhouette information according to a given clustering in k clusters
sil <- silhouette(x = UPGMA.6groups, # Vector with k different integer cluster codes.
dist = macnally.dist # Original a dissimilarity object.
)
# give the names to sil based on of sites
rownames(sil) <- row.names(macnally.clean)
# Silhouette plot of the final partition
plot(x = sil, # The silhouette object
main = "Silhouette plot - Bray Curtis - UPGMA", # Main tytle
cex.names = 0.8, # Size of text
col = 2:(k + 1) # Bar colours (one per group)
)
macnally.chwo <- reorder(x = Hclus.3, # Hierarchical clustering from hclust
wts = macnally.dist # numeric vector for reordering
)
# Plotting the new dendrogram
plot(macnally.chwo)
# Plot reordered dendrogram with habitat as leaves names
plot(macnally.chwo, # An object of the type produced by hclust.
hang = -1, # Where should labels hang below the tips.
xlab = "6 groups", # X-axis label.
ylab = "Height", # Y-axis label.
main = "Bray Curtis - UPGMA (reordered)", # Main title
labels = macnally$HABITAT) # Labels for the leaves of the tree
# Using the rect.hclust() function (see ?rect.hclusto so you know how to use the function) add boxes for the six-groups classification selected
rect.hclust(tree = macnally.chwo, # an object of the type produced by hclust
k = 6, # How many clusters?
border = 1:k, # Border colours for the rectangles
)
ade4::is.euclid(macnally.dist)
??is.euclid
install.packages("ade4")
ade4::is.euclid(macnally.dist)
macnally.dist.Ling <- sqrt(macnally.dist)+1
# Is it euclidean?
ade4::is.euclid(macnally.dist.Ling)
macnally.dist.Cail <- macnally.dist+1
macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, # An Euclidean distance matrix.
k = (nrow(macnally.clean) - 1), # Number of dimensiosn.
eig = TRUE # eigenvalues should be returned?
)
macnally.dist.Sqrt <- sqrt(macnally.dist)
macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, # An Euclidean distance matrix.
k = (nrow(macnally.clean) - 1), # Number of dimensiosn.
eig = TRUE # eigenvalues should be returned?
)
# Print the structure of the object created with the cmdscale() function.
str(macnally.pcoa.V1)
macnally.CumulEig <- macnally.pcoa.V1$ values$Cumul_eig
macnally.barplot <- barplot(macnally.CumulEig)
macnally.CumulEig
macnally.pcoa.V1$ values
macnally.pcoa.V1
macnally.CumulEig <- macnally.pcoa.V1$eig
macnally.barplot <- barplot(macnally.CumulEig)
macnally.CumulEig
macnally.pcoa.V1
library(ape)
# PCoA using pcoa - see that the number of PCoA assess to be extracted is defined
macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,# An Euclidean distance matrix.
correction = "none" # How to correct the distance matrix?
)
# Print the structure of the object created with the pcoa() function.
str(macnally.pcoa.V2)
```
macnally.CumulEig <- macnally.pcoa.V1$ values$Cumul_eig
macnally.CumulEig <- macnally.pcoa.V2$ values$Cumul_eig
macnally.barplot <- barplot(macnally.CumulEig)
text(x = as.numeric(macnally.barplot)-0.5, # X-axis location.
y = rep(0, length(macnally.CumulEig)), # Y-axis location.
labels = paste(1:length(macnally.CumulEig), "PCoA", sep = "_"), # Text
srt = 45, xpd = NA, cex = 0.5, # Text arguments: angle (srt), plot in the full area (xpd), size of the text
pos = 1 # Position specifier for the text.
)
macnally.CumulBrStick <-macnally.pcoa.V2$ values$Cumul_br_stick
lines(x = macnally.barplot, # X-axis position.
y = macnally.CumulBrStick, # Y-axis = Cumulative broken stick fractions
type = "o", # type of plot desired = overplotted points and lines
col = "red" # colour
)
max(which(macnally.CumulEig>macnally.CumulBrStick))
ordiplot(ord = macnally.pcoa.V2, # A result from an ordination.
choices = c(1, 2), # Which axes to show?
type = "t", # type of graph which may be "points", "text" or "none"
main = "PCoA with species weighted averages" # main titale
)
ordiplot(ord = macnally.pcoa.V1, # A result from an ordination.
choices = c(1, 2), # Which axes to show?
type = "t", # type of graph which may be "points", "text" or "none"
main = "PCoA with species weighted averages" # main titale
)
abline(h = 0, v = 0, lty = 3)
ordiplot(ord = macnally.pcoa.V2)
abline(h = 0, v = 0, lty = 3)
spe.wa <- wascores(x = macnally.pcoa.V1$points[, 1:2], # Environmental variables
w = macnally.clean) # Weights
text(x = spe.wa, # Weighted Averages Scores for Species
labels = rownames(spe.wa), # Text to be written.
cex = 0.7, col = "red" # Text arguments.
)
par(mar=rep(0,4), oma=rep(0,4))
# Biplots based on pcoa
biplot.pcoa(x = macnally.pcoa.V2, # Output object from pcoa
Y = macnally.clean, # Variables to be projected onto the ordination plot
main = "PCoA Biplot\n Response variables Projected as in PCA" # Main title
)
# Add a vertical and horizontal doted line at 0.
abline(h = 0, v = 0, lty = 3)
biplot(x = macnally.pcoa.V2, # Output object from pcoa
main = "PCoA with species weighted averages" # Main title
)
# Add a vertical and horizontal doted line at 0.
abline(h = 0, v = 0, lty = 3)
# Plot polygons grouping observations by cluster.
ordihull(ord = macnally.pcoa.V1, # A result from an ordination.
choices = c(1, 2), # Axes shown.
groups = cutree(Hclus.3, 6), # Factor giving the groups for which the graphical item is drawn
draw = "polygon", # ow should objects be represented on the plot? (lines or polygon )
col = 1:6 # Colour for each group.
)
set.seed(99) # To ensure the results match those below
macnally.MDS.V1 <- metaMDS(comm = macnally.clean, # Community data.
k = 2, # Number of dimensions.
distance = "bray", # Dissimilarity index used?
try = 20, # Minimum numbers of random starts?
trace = 0 # Added to avoid printing the procedure
)
macnally.MDS.V1
set.seed(99) # To ensure the results match those above
macnally.MDS.V2 <- metaMDS(comm = macnally.dist, # Dissimilarities
k = 2, # Number of dimensions.
try = 20, # Minimum numbers of random starts?
trace = 0 # Added to avoid printing the procedure
)
macnally.MDS.V2
macnally.MDS.V1$stress
stressplot(object = macnally.MDS.V1, # The metaMDS model
pch = 19 , lty = 2# Point and line arguments
)
stressplot.Bct <- sapply(2:20,
function(k){
NMDSTemp <- metaMDS(comm = macnally.dist, # Dissimilarities
k = k, # Number of dimensions.
try = 20, # Minimum numbers of random starts?
trace = 0 # Added to avoid printing the procedure
)
NMDSTemp$stress # Extract the from the NMDS object.
})
## plot the Shepard stress plot
plot(x = 2:20, # Number of axes
y = stressplot.Bct, # Stress value
type = "o", # Plot type
pch = 19, # Type of point.
col = "red", # Colour fo the point.
ylab = "Stress", # Y-axis label.
xlab = "Number of dimensions"# X-axis label.
)
# Add the 0.1 critical value line
abline(h = 0.1, # The y-value(s) for horizontal line(s).
lty = 3, lwd = 2 # Line width and type arguments.
)
# Add the 0.05 critical value line
abline(h = 0.05, # The y-value(s) for horizontal line(s).
lty = 4, lwd = 2 # Line width and type arguments.
)
# Add a legend indicating the line type for each critical value
legend("topright", # Position the legend?
lty = c(3,2), # The type of lines for each class.
legend = c(0.1,0.5), # The Text for each class in in the legend.
title = "Critical Values" # Main title
)
StressChng <- stressplot.Bct[1:18] - stressplot.Bct[2:19]
## Plot the relative change in stress
StressChngBrPlt <- barplot(height = StressChng, # matrix of values describing the bars.
names.arg = paste(2:18, 3:20, sep = "to"), # A vector of names to be plotted below each bar.
xlab = "Change in dimensions", # X-axis label.
ylab = "Change in stress",# y-axis label.
las = 2 # Axis text orientation.
)
# Add a line showing the change in cumulative stress
lines(x = StressChngBrPlt, # X-axis position.
y = StressChng, # Cumulative stress.
type = "b", # Type of plot.
pch = 19, # Point type.
col = "red", #Point/line colour.
lwd = 3) # Line Arguments.
kUse <- min(which(stressplot.Bct<0.05))
# Print the stress value for the selected number of axes.
stressplot.Bct[kUse]
# Build the final NMDS
macnally.MDS.V3 <- metaMDS(comm = macnally.dist, # Dissimilarities
k = kUse+1, # Number of dimensions.
try = 20, # Minimum numbers of random starts?
trace = 0 # Added to avoid printing the procedure
)
# Set a Plotting space
par(mfrow = c(1, 2))
# Make a stressplot of the final NMDS
# Add the stress value to the figure main title.
stressplot(object = macnally.MDS.V3,
main = paste0("NMDS with 6 axes\n Stress =",
round(macnally.MDS.V3$stress,3)))
# Make a stressplot of the NMDS  with 2 axes.
# Add the stress value to the figure main title.
stressplot(object = macnally.MDS.V1,
main = paste0("NMDS with 2 axes\n Stress =",
round(macnally.MDS.V1$stress,3))
)
macnally.MDS.V4 <- metaMDS(comm = macnally.clean, # Community data.
k = 3, # Number of dimensions.
distance = "bray", # Dissimilarity index used?
try = 20, # Minimum numbers of random starts?
trace = 0 # Added to avoid printing the procedure
)
# Set plotting space
par(mfrow = c(2,2))
# plot the first and second  NMDS axes
plot(macnally.MDS.V4, # The NMDS object
display = c("species", "sites"), # Display "sites" AND "species".
choices = c(1, 2), # Axes shown
type = "p", # Plot type: "p" for points, "t" for text, and "n" for axes only.
main = c("NMDS axes 1 and 2") # main Title
)
# Plot the first and third two NMDS axes
plot(macnally.MDS.V4, # The NMDS object
display = c("species", "sites"), # Display "sites" AND "species".
choices = c(1, 3), # Axes shown
type = "p", # Plot type: "p" for points, "t" for text, and "n" for axes only.
main = c("NMDS axes 1 and 3") # main Title
)
# Plot the second and third two NMDS axes
plot(macnally.MDS.V4, # The NMDS object
display = c("species", "sites"), # Display "sites" AND "species".
choices = c(2, 3), # Axes shown
type = "p", # Plot type: "p" for points, "t" for text, and "n" for axes only.
main = c("NMDS axes 2 and 3") # main Title
)
# Creates an empty ordination space
ordiplot(ord = macnally.MDS.V4, # Ordination output.
choices = c(1, 2), # Axes shown
type = "none" # type of graph? use "none"
)
## Add the Species names to the ordination space
orditorp(x = macnally.MDS.V4, # Ordination output.
display = "species", # Items to be displayed in the plot.
col = "red",
air = 0.01)
## Add the Sites names to the ordination space
orditorp(macnally.MDS.V4,# Ordination output.
display = "sites", # Items to be displayed in the plot.
cex = 0.8,
air = 0.01)
# Creates an empty ordination space
ordiplot(ord = macnally.MDS.V4, # Ordination output.
choices = c(1, 2), # Axes shown
type = "none" # type of graph? use "none"
)
macnally.MDS.V4
plot(macnally.MDS.V4, # The NMDS object
display = c("species", "sites"), # Display "sites" AND "species".
choices = c(2, 3), # Axes shown
type = "p", # Plot type: "p" for points, "t" for text, and "n" for axes only.
main = c("NMDS axes 2 and 3") # main Title
)
macnally.MDS.V4
ordiplot(ord = macnally.MDS.V4, # Ordination output.
choices = c(1, 2), # Axes shown
type = "none" # type of graph? use "none"
)
orditorp(x = macnally.MDS.V4, # Ordination output.
display = "species", # Items to be displayed in the plot.
col = "red",
air = 0.01)
orditorp(macnally.MDS.V4,# Ordination output.
display = "sites", # Items to be displayed in the plot.
cex = 0.8,
air = 0.01)
# Define the plotting space.
par(mfrow = c(2, 2))
# Create a list with the axes pairs
PairList <- list(c(1,2),
c(1,3),
c(2,3))
for (i in 1:3){
## Plot axis based on Pair List
plot(macnally.MDS.V4$points[,PairList[[i]]], # Which to axis to plot.
pch = 19, # Type of point.
col = factor(macnally$HABITAT), #Give the point colours based on the habitat.
main = paste0("NMDS axes ",
PairList[[i]][1],
" vs. " ,
PairList[[i]][2])
)
## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$points[, PairList[[i]]], # An ordination object
groups = factor(macnally$HABITAT), # Factor giving the groups for
draw = "polygon", # What to draw? lines or polygons?
col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.
label = F)
}
# Add a legend with the Habitat types
plot.new()
legend("bottomleft", # Position the legend?
fill = 1:length(unique(macnally$HABITAT)), #The type of colours  for each class.
legend = unique(macnally$HABITAT), # # The Text for each class in in the legend
title = "Habitat types", # Main title
xpd=NA)
PairList <- list(c(1,2),
c(1,3),
c(2,3))
par(mfrow = c(2, 2),
mar = c(3,3,3,3))
for (i in 1:3){
# plot axis 1 and 2
ordiplot(macnally.MDS.V4,
choice = PairList[[i]],
type = "n",
main = paste0("NMDS axes ",
PairList[[i]][1],
" vs. " ,
PairList[[i]][2])
)
## Plot sites and colour code names based on habitat
orditorp(macnally.MDS.V4,
choice = PairList[[i]],
display = "sites",
col = as.numeric(factor(macnally$HABITAT)),
air = 0.01,
cex = 0.8)
}
PairList <- list(c(1,2),
c(1,3),
c(2,3))
for (i in 1:3){
## Plot axis based on Pair List
plot(macnally.MDS.V4$points[,PairList[[i]]], # Which to axis to plot.
pch = 19, # Type of point.
col = factor(macnally$HABITAT), #Give the point colours based on the habitat.
main = paste0("NMDS axes ",
PairList[[i]][1],
" vs. " ,
PairList[[i]][2])
)
## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$points[, PairList[[i]]], # An ordination object
groups = factor(macnally$HABITAT), # Factor giving the groups for
draw = "polygon", # What to draw? lines or polygons?
col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.
label = F)
}
## Plot axis based on Pair List
plot(macnally.MDS.V4$points[,c(1,2)], # Which to axis to plot.
pch = 19, # Type of point.
col = factor(macnally$HABITAT), #Give the point colours based on the habitat.
main = "NMDS axes 1 an 2")
## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$points[, c(1,2)], # An ordination object
groups = factor(macnally$HABITAT), # Factor giving the groups for
draw = "polygon", # What to draw? lines or polygons?
col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.
label = F)
legend("bottomleft", # Position the legend?
fill = 1:length(unique(macnally$HABITAT)), #The type of colours  for each class.
legend = unique(macnally$HABITAT), # # The Text for each class in in the legend
title = "Habitat types", # Main title
xpd=NA)
## Plot axis based on Pair List
plot(macnally.MDS.V4$points[,c(1,2)], # Which to axis to plot.
pch = 19, # Type of point.
col = factor(macnally$HABITAT), #Give the point colours based on the habitat.
main = "NMDS axes 1 an 2")
## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$points[, c(1,2)], # An ordination object
groups = factor(macnally$HABITAT), # Factor giving the groups for
draw = "polygon", # What to draw? lines or polygons?
col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.
label = F)
legend("bottomleft", # Position the legend?
fill = 1:length(unique(macnally$HABITAT)), #The type of colours  for each class.
legend = unique(macnally$HABITAT), # # The Text for each class in in the legend
title = "Habitat types", # Main title
xpd=NA,
cex=0.2)
## Plot axis based on Pair List
plot(macnally.MDS.V4$points[,c(1,2)], # Which to axis to plot.
pch = 19, # Type of point.
col = factor(macnally$HABITAT), #Give the point colours based on the habitat.
main = "NMDS axes 1 an 2")
## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$points[, c(1,2)], # An ordination object
groups = factor(macnally$HABITAT), # Factor giving the groups for
draw = "polygon", # What to draw? lines or polygons?
col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.
label = F)
legend("bottomleft", # Position the legend?
fill = 1:length(unique(macnally$HABITAT)), #The type of colours  for each class.
legend = unique(macnally$HABITAT), # # The Text for each class in in the legend
title = "Habitat types", # Main title
xpd=NA,
cex=0.5)
install.packages(c("ade4", "brew", "callr", "car", "cli", "collections", "commonmark", "cpp11", "crayon", "curl", "digest", "dotCall64", "e1071", "evaluate", "fontawesome", "gstat", "isoband", "jsonlite", "languageserver", "learnr", "lifecycle", "lintr", "lme4", "maps", "maptools", "markdown", "minqa", "openssl", "pkgload", "processx", "ps", "purrr", "R.utils", "renv", "rlang", "rmarkdown", "rsconnect", "shiny", "styler", "sys", "testthat", "tidyselect", "tinytex", "vctrs", "xfun", "xts", "yaml"))
install.packages("MASS")
devtools::check()
install.packages("devtools")
devtools::check()
devtools::install_version("MASS", "7.3-57.1")
