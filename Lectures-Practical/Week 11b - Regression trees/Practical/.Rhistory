# Change the names of landsat8 using the names() function.
names(landsat8) <- c("Coastal",'blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
# Print the output of the landsat8 object.
landsat8
NDVI <- (landsat8[[5]] - landsat8[[4]])/(landsat8[[5]] + landsat8[[4]])
BASEMAP2018 <- raster("Data/BASEMAP-2018.tif")
plot(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
image(x = BASEMAP, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
classdf <- read.csv2("Data/Aggregated Legend.csv")
samp2018 <- sampleStratified(x = BASEMAP2018, # Raster to be "sampled"
size = 200, # Number of samples per class
na.rm = TRUE, # NA values are removed from random sample?
sp = TRUE # Output as a SpatialPointsDataFrame?
)
samp2018
class(samp2018)
head(samp2018)
SampLCC <- samp2018$layer
table(SampLCC)
sampvals <- extract(x = landsat8, # Define the raster to be samples.
y = samp2018, # Define the spatial vector data with the locations to sample.
df = TRUE # Return the results as a data.frame?
)
sampvals <- sampvals[, -1]
sampdata <- data.frame(classvalue = samp2018@data$BASEMAP2018, # Get the Landcover "class" for each selected location.
sampvals # The data.frame with the hyperspectral bands in `landsat8`.
)
samp2018@data
sampdata <- data.frame(classvalue = samp2018@data$layer, # Get the Landcover "class" for each selected location.
sampvals # The data.frame with the hyperspectral bands in `landsat8`.
)
head(sampdata)
sampdata.agg <-  data.frame(classvalue = sampdata[, 1], # Define the Land cover class
Band = "B1", # Define the Band Name.
WaveLng = sampdata[, 2] # Get the wave-length values for the selected Band.
)
for( x  in 3:7){
# Extract the values
sampdata.Tmp <- data.frame(classvalue = sampdata[, 1], # Define the Land cover class
Band = names(sampdata)[x], # Define the Band Name
WaveLng = sampdata[, x] # Get the wave-length values for the selected Band.
)
# Merge the temp table to sampdata.agg
sampdata.agg <- rbind(sampdata.agg, # The aggregated table.
sampdata.Tmp  # The temp table.
)
}
summary(sampdata.agg)
NLandClas <- length(unique(sampdata$classvalue))
boxplot(log10(WaveLng)~classvalue:Band, ## this notation defines land cover types within each band
data =  sampdata.agg, # The source data
col = classdf$classcolor, # gives one colour to each land cover types
axes = F # Do not add axes
)
axis(2, las = 2) # Adds the y axes
abline(v = seq(0.5,
dim(unique(sampdata.agg[, 1:2]))[1]+0.5,
by = NLandClas),
lty = 2)
axis(1,
at = seq(4,
dim(unique(sampdata.agg[, 1:2]))[1],
by = NLandClas),
labels = names(landsat8))
Nbands <- length(names(sampdata)[-1])
boxplot(log10(WaveLng)~Band:classvalue, ## this notation defines bands within a land cover type
data =  sampdata.agg,
col = c("#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e", "#e6ab02"),  # gives one colour to each band
axes = F)
axis(2, las = 2)# Adds the y axes
abline(v = seq(0.5,
dim(unique(sampdata.agg[, 1:2]))[1]+0.5,
by = Nbands),
lty = 2)
axis(1,
at = seq(4,
dim(unique(sampdata.agg[, 1:2]))[1],
by = Nbands),
labels = classdf$BASEMAPclass,
cex = 0.8)
box()
library(rpart)
cartMod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = sampdata, # Define the object with the response/predictors data!
method = 'class', # Define the Type of model you are building.
cp = 0.01, # Define the minimum level of increase in the complexity parameter
minsplit = 5 #Define the minimum number of observations that must exist in a node in order for a split to be attempted
)
cartMod
plot(x = cartMod, # Define the classification/regression tree to plot.
uniform = TRUE, # Use a uniform vertical spacing of the nodes?
main = "Classification Tree" # Figure main title
)
text(x = cartMod, # Define the classification/regression tree to plot,
cex = 0.8 # Size of the text
)
printcp(cartMod)
# Plot a Complexity Parameter Table for a rpart Fit. Here note the dashed line, which shows the 1-SE of the minimum cp.
plotcp(cartMod)
printcpSumm <- as.data.frame(printcp(cartMod))
CPVal.Min <- printcpSumm[which.min(printcpSumm$xerror), "CP"]
cartMod.pruned.1 <- prune(cartMod, # Define the CART model to prune.
cp = CPVal.Min # Define the CP value at which the CART model will be pruned
)
plot(x = cartMod.pruned.1, # Define the classification/regression tree to plot.
uniform = TRUE, # Use a uniform vertical spacing of the nodes?
main = "Classification Tree - min criteria" # Figure main title
)
text(x = cartMod.pruned.1, # Define the classification/regression tree to plot,
cex = 0.8, # Size of the text
xpd = NA)
BASEMAP
image(x = BASEMAP2018, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
table(BASEMAP2018)
table(BASEMAP2018[])
names(table(BASEMAP2018[]))
table(BASEMAP2018[])?reclassify
?reclassify
rclmat <- matrix(c(110000, 129999, 1, # Build
130000, 139999, 2, # Recreation
140000, 159999, 3, #Infrastructure
160000, 169999, 4, # Mining
200000, 290000, 5, # Agriculture
300000, 390000, 6, # Nature
400000, 499999, 7, # Aquatic
500000, Inf, NA), # Unmapped
ncol=3, byrow=TRUE)
BASEMAP2018ReCls <- reclsify(BASEMAP2018,
rclmat)
BASEMAP2018ReCls <- reclassify(BASEMAP2018,
rclmat)
image(x = BASEMAP2018ReCls, # raster to plot.
col = hcl.colors(7, palette = "Zissou") # Define the colour ramp
)
image(x = BASEMAP2018ReCls)
BASEMAP2018ReCls
BASEMAP2018ReCls[]
rclmat <- matrix(c(109999, 129999, 1, # Build
129999, 139999, 2, # Recreation
140000, 159999, 3, #Infrastructure
160000, 169999, 4, # Mining
200000, 290000, 5, # Agriculture
300000, 390000, 6, # Nature
400000, 499999, 7, # Aquatic
500000, Inf, NA), # Unmapped
ncol=3, byrow=TRUE)
BASEMAP2018ReCls <- reclassify(BASEMAP2018,
rclmat)
image(x = BASEMAP2018ReCls), # raster to plot.
BASEMAP2018ReCls
rclmat <- matrix(c(109999, 129999, 1, # Build
129999, 139999, 2, # Recreation
140000, 159999, 3, #Infrastructure
160000, 169999, 4, # Mining
200000, 290000, 5, # Agriculture
300000, 390000, 6, # Nature
400000, 499999, 7, # Aquatic
500000, Inf, NA), # Unmapped
ncol=3, byrow=TRUE)
# reclassify the values into seven groups
BASEMAP2018ReCls <- reclassify(BASEMAP2018,
rclmat)
image(x = BASEMAP2018ReCls)
image(x = BASEMAP2018ReCls, # raster to plot.
col = hcl.colors(7, palette = "Zissou") # Define the colour ramp
)
set.seed(99)
# Sampling
samp2018 <- sampleStratified(x = BASEMAP2018ReCls, # Raster to be "sampled"
size = 200, # Number of samples per class
na.rm = TRUE, # NA values are removed from random sample?
sp = TRUE # Output as a SpatialPointsDataFrame?
)
# What kind of object is samp2018?
class(samp2018)
head(samp2018)
image(BASEMAP2018ReCls,
main = "Land cover classification 2011", # Give the Name
)
points(samp2018, # Define the SpatialPointsDataFrame to plot
pch = 10 # Define the type of point.
)
legend("bottomright", # Define the position the legend.
inset = c(-0.24,0), # Define inset distance(s) from the margins.
pch = 10, # Define the point shape for sampled locations.
legend  = "Sampled locations.", # Define How you are naming these sampled locations.
cex=0.7,
xpd=NA) # Plot outside the Figure region
SampLCC <- samp2018$layer
# Use the table() function to tabulate the number of land cover classes sampled by the `sampleStratified` function
table(SampLCC)
sampvals <- extract(x = landsat8, # Define the raster to be samples.
y = samp2018, # Define the spatial vector data with the locations to sample.
df = TRUE # Return the results as a data.frame?
)
sampvals <- sampvals[, -1]
sampdata <- data.frame(classvalue = samp2018@data$layer, # Get the Landcover "class" for each selected location.
sampvals # The data.frame with the hyperspectral bands in `landsat8`.
)
head(sampdata)
library(rpart)
# Train the model
cartMod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = sampdata, # Define the object with the response/predictors data!
method = 'class', # Define the Type of model you are building.
cp = 0.01, # Define the minimum level of increase in the complexity parameter
minsplit = 5 #Define the minimum number of observations that must exist in a node in order for a split to be attempted
)
cartMod
plot(x = cartMod, # Define the classification/regression tree to plot.
uniform = TRUE, # Use a uniform vertical spacing of the nodes?
main = "Classification Tree" # Figure main title
)
# Place the leafs Names on the dendrogram Plot
text(x = cartMod, # Define the classification/regression tree to plot,
cex = 0.8 # Size of the text
)
printcp(cartMod)
plotcp(cartMod)
printcpSumm <- as.data.frame(printcp(cartMod))
CPVal.Min <- printcpSumm[which.min(printcpSumm$xerror), "CP"]
cartMod.pruned.1 <- prune(cartMod, # Define the CART model to prune.
cp = CPVal.Min # Define the CP value at which the CART model will be pruned
)
# Plot the Pruned tree
plot(x = cartMod.pruned.1, # Define the classification/regression tree to plot.
uniform = TRUE, # Use a uniform vertical spacing of the nodes?
main = "Classification Tree - min criteria" # Figure main title
)
text(x = cartMod.pruned.1, # Define the classification/regression tree to plot,
cex = 0.8, # Size of the text
xpd = NA)
rsq.rpart(cartMod)
cartMod.pruned.3 <- prune(cartMod, # Define the CART model to prune.
cp = printcpSumm$CP[printcpSumm$nsplit == 6] # Define the CP value at which the CART model will be pruned
)
plot(x = cartMod.pruned.3, # Define the classification/regression tree to plot.
uniform = TRUE, # Use a uniform vertical spacing of the nodes?
main = "Classification Tree - asymptotic criteria" # Figure main title
)
text(x = cartMod.pruned.3, # Define the classification/regression tree to plot,
cex = 0.8, # Size of the text
xpd = NA)
library(randomForest)
# Build a random forest model that predicts land cover classes based on the hyperspectral signal of sampled sites.
# As for CART, your response variable should be a factor.
RF.model <- randomForest(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = sampdata, # Define the data frame containing the variables in the model.
ntree = 500, # Define the number of trees to grow. By default, the function builds 500 trees.
mtry = 2, # Define the Number of variables randomly sampled as candidates at each split. By default, the function uses two (2) predictors per tree.
importance = TRUE # Should the importance of predictors be assessed?
)
# Print the randomForest just created
RF.model
RF.Error.ntree <- data.frame(ntree = c(100, 500, 1000, 2000,  5000), # A vector with the Number of trees
OOB = NA  # Set the OOB to NA - will be filled for each Number of trees below1
)
for(i in RF.Error.ntree$ntree){
# Set the random seed for repeatability
set.seed(99)
# Estimate the randomForest for the evaluated Number of trees
RF.mode.tmp <- randomForest(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = sampdata, # Define the data frame containing the variables in the model.
ntree = i, # Define the number of trees to grow.
mtry = 2, # Define the Number of variables randomly sampled at each split. Use the Default = 2.
importance = TRUE # Should importance of predictors be assessed?
)
# Add the estimated OOB-error to `RF.Error.ntree` - the summary data.frame
RF.Error.ntree$OOB [RF.Error.ntree$ntree ==i] <-  RF.mode.tmp$err.rate[dim(RF.mode.tmp$err.rate)[1]]
}
RF.Error.ntree
RF.Error.mtry <- data.frame(mtry = 1:6,# A vector with the Number of variables
OOB = NA  # Set the OOB to NA - will be filled for each Number of trees below1
)
# Loop over RF.Error.mtry$mtry to assess the impact of tree number on OOB-error.
for(i in RF.Error.mtry$mtry){
# Set the random seed for repeatability
set.seed(99)
# Estimate the randomForest for the evaluated Number of variables
RF.mode.tmp <- randomForest(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = sampdata, # Define the data frame containing the variables in the model.
ntree = 500, # Define the number of trees to grow. Use the Default = 500
mtry = i, # Define the Number of variables randomly sampled at each split.
importance = TRUE # Should importance of predictors be assessed?
)
# Add the estimated OOB-error to the summary data.frame
RF.Error.mtry$OOB [RF.Error.mtry$mtry ==i] <-  RF.mode.tmp$err.rate[dim(RF.mode.tmp$err.rate)[1]]
}
# Print the summary data.frame
RF.Error.mtry
predRF <- predict(object = RF.model, # Define the randomForest with the model.
newdata = sampdata, # Define data.frame used to make the prediction - here is the training data.
type = "response" # indicating the type of output:
)
# Tabulate the observed vs. predicted classification - this is a type of confusion matrix!
table(predRF, sampdata$classvalue)
importance(RF.model)
# Plot the variable importance measures for the best attribute configuration of your randomForest model using the varImpPlot() function
varImpPlot(RF.model)
library(dismo)
set.seed(99)
# Do a k-fold partitioning of the training dataset
k.foldDta <- kfold(sampdata, # the source data to use
k = 5, # number of Folds (here you use 5)
by = sampdata$classvalue) # define how to stratify the folds
# Tabulate the k-fold partitioning dataset by the Land Cover Class to see the number of samples per land cover class to be used in each fold.
table(k.foldDta,sampdata$classvalue)
CART.Kfold.List <- lapply(1:5, function(k){
# Define the Training data.frame - Observations NOT selected in the k-fold.
train <- sampdata[k.foldDta!= k, ]
# Define the test data.frame - Observations selected in the k-fold.
test <- sampdata[k.foldDta == k, ]
# Build a new CART model using the Train dataset
cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = train, # Define the object with the response/predictors data!
method = 'class', # Define the Type of model you are building.
cp = 0.01, # Define the minimum level of increase in the complexity parameter
minsplit = 5 #Define the minimum number of observations that must exist in a node for a split to be attempted
)
# Predict the k-fold model on the test data.frame
pclass <- predict(object = cartMod.kfold.Mod, # Define the randomForest with the model.
newdata = test, # Define data.frame used to make the prediction - here is the training data.
type = "class" # indicating the type of output
)
# create a table to compare the test-data and the prediction
cbind(Obsered = test$classvalue,
Predicted = as.integer(pclass))/dim(test)[1]
})
CART.Kfold <- do.call("rbind",
CART.Kfold.List)
# Make the matrix a data.frame
CART.Kfold <- data.frame(CART.Kfold)
# Set the column names for the data.frame.
colnames(CART.Kfold) <- c('observed', 'predicted')
# Tabulate the (miss)matches between the observed  and predicted test datasets
CART.conmat <- table(CART.Kfold)
# Change the name of the classes in the tabulation.
colnames(CART.conmat) <- classdf$BASEMAPclass
rownames(CART.conmat) <- classdf$BASEMAPclass
# Print the confusion matrix
CART.conmat
(BASEMAP2018ReCls[])
CART.conmat
# Kfold Validation for the RF model
RF.Kfold.List <- lapply(1:5, function(k){
# Define the Training data.frame - Observations NOT selected in the k-fold.
train <- sampdata[k.foldDta!= k, ]
# Define the test data.frame - Observations selected in the k-fold.
test <- sampdata[k.foldDta == k, ]
# build a new model using the Train dataset
RF.model.kfold.Mod <- randomForest(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in landsat8) - remember to Define the Land cover class as a factor
data = train, # Define the data frame containing the variables in the model.
ntree = 500, # Define the number of trees to grow. Use the Default = 500
mtry = i, # Define the Number of variables randomly sampled at each split.
importance = TRUE # Should importance of predictors be assessed?
)
# Predict the k-fold model
pclass <- predict(object = RF.model.kfold.Mod, # Define the randomForest with the model.
newdata = test, # Define data.frame used to make the prediction - here is the training data.
type = "response" # indicating the type of output
)
# create a data.frame using the reference and prediction
cbind(Obsered = train$classvalue,
Predicted = as.integer(pclass))
})
# Confusion matrix for CART model the kfold validation
# Merge the tables in the list row wise
RF.Kfold <- do.call("rbind",
RF.Kfold.List)
# Make the matrix a data.frame
RF.Kfold <- data.frame(RF.Kfold)
# Set the column names for the data.frame.
colnames(RF.Kfold) <- c('observed', 'predicted')
# Tabulate the (miss)matches between the observed  and predicted test datasets
RF.conmat <- table(RF.Kfold)
# Change the name of the classes in the tabulation.
colnames(RF.conmat) <- classdf$BASEMAPclass
rownames(RF.conmat) <- classdf$BASEMAPclass
# Print the confusion matrix
RF.conmat
ART.pr2011 <- predict(object = landsat8, # Define the raster used to make the predictions.
model = cartMod, # Define the model used to make the predictions..
type = 'class' # Define the type of predicted value returned
)
# Plot the CART model PREDICTED map using the image() function and the HEX colours in classdf - remember that there is no class 6 in classdf, and so it does not have a colour.
image(CART.pr2011,
main = "CART Predicted Land cover classification 2011")
CART.pr2018 <- predict(object = landsat8, # Define the raster used to make the predictions.
model = cartMod, # Define the model used to make the predictions..
type = 'class' # Define the type of predicted value returned
)
image(CART.pr2018,
main = "CART Predicted Land cover classification 2011")
# Load the required library (raster)
library("raster")
# Use `stack()` to load the file and save it as an object named landsat8.
landsat8 <- stack("Data/Aarhus_2019_utm_L8.tif")
# Change the names of landsat8 using the names() function.
names(landsat8) <- c("Coastal",'blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
# Print the output of the landsat8 object.
landsat8
# Load the file and save it as an object named BASEMAP2018
BASEMAP2018 <- raster("Data/BASEMAP-2018.tif")
# plot the `BASEMAP2018`
image(x = BASEMAP2018, # raster to plot.
col = sample(hcl.colors(35, palette = "Zissou")) # Define the colour ramp
)
rclmat <- matrix(c(109999, 129999, 1, # Build
129999, 139999, 2, # Recreation
139999, 159999, 3, # Infrastructure
159999, 169999, 4, # Mining
169999, 290000, 5, # Agriculture
290000, 390000, 6, # Nature
390000, 499999, 7, # Aquatic
499999, Inf, NA), # Unmapped
ncol=3, byrow=TRUE)
# reclassify the values into seven groups
BASEMAP2018ReCls <- reclassify(BASEMAP2018,
rclmat)
BASEMAP2018>
# plot the reclassify raster
image(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black","orange","dark green","blue"))
plot(BASEMAP2018ReCls == 1)
View(BASEMAP2018ReCls)
View(BASEMAP2018ReCls)
BASEMAP2018ReCls2==1
plot(BASEMAP2018ReCls==1,col=c("grey",NA))
plot(BASEMAP2018ReCls==1,col=c(,NA))
plot(BASEMAP2018ReCls==1,col=c(,NA))
plot(BASEMAP2018ReCls==1,col=c(NA,"grey"))
plot(BASEMAP2018ReCls==2,col=c(NA,"light green"))
table(BASEMAP2018ReCls)
table(BASEMAP2018ReCls[])
image(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black",NA,"orange","dark green","blue"))
plot(BASEMAP2018ReCls)
BASEMAP2018ReCls
image(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black","orange","dark green","blue"))
plot(BASEMAP2018ReCls==1)
plot(BASEMAP2018ReCls==2)
plot(BASEMAP2018ReCls==3)
plot(BASEMAP2018ReCls==3,col=c("NA","black"))
plot(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black","orange","dark green","blue"))
image(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black","orange","dark green","blue"))
plot(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black","orange","dark green","blue"),
lehend=F)
?plot.raster
?imagfe
?image
image(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black","orange","dark green","blue",NA))
image(x = BASEMAP2018ReCls, # raster to plot.
col = c("grey","light green","black",NA,"orange","dark green","blue"))
require(raster)
a<-raster(ncol=100,nrow=100)
a[] <- runif(10000)
plot(a)
hist(a)
b <- a >0.5
plot(b)
b[]
b[]*1
which(b[]*1==1)
sample(which(b[]*1==1),10)
coordinates(b)[sample(which(b[]*1==1),10)]
coordinates(b)[sample(which(b[]*1==1),10),]
?rasterize
coordiates(b)
coordinates(b)
?extract
?over
