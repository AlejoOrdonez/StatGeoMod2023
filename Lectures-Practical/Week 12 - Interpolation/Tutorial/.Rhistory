names(DMI.Stations)
# Print the dimensions in DMI.Stations
dim(DMI.Stations)
library(sp)
# Transform the data.frame into a SpatialPointsDataFrame
DMI.Stations.Shp <- SpatialPointsDataFrame(coords = DMI.Stations[, c("Longitude", "Latitude")],
data = DMI.Stations,
proj4string = CRS("+proj=longlat +datum=WGS84 +no_defs"),
match.ID = TRUE)
# Load the required library (maptools)
library(maptools)
# Load a world map
data(wrld_simpl)
# Plot the location of the weather stations
plot(DMI.Stations.Shp,
pch = 19, cex = 0.5, col = "red")
# Plot the World map
plot(wrld_simpl, add = T)
# Add a bounding box and some tick marks to define the latitude-longitude point
box(); axis(1, labels = NA); axis(2, labels = NA);  axis(3, labels = NA); axis(4, labels = NA)
# Define those observations within Denmark
DK.Sites <- which(DMI.Stations.Shp$Country == "DNK") # DNK is the ISO code for Denmark
# Generate a SpatialPointsDataFrame only for the weather stations in Denmark
DMI.DK.Shp <- DMI.Stations.Shp[DK.Sites, ]
# Print a summary of DMI.DK.Shp
summary(DMI.DK.Shp)
# Plot the location of all the Weather stations
plot(DMI.DK.Shp,
pch = 19, cex = 0.5, col = "red")
# Plot the World map
plot(wrld_simpl, add = T)
# Add a bounding box and some tick marks to define the latitude-longitude point
box(); axis(1, labels = NA); axis(2, labels = NA);  axis(3, labels = NA); axis(4, labels = NA)
library(raster)
# Get the country administrative boundaries for Denmark, Sweden, and Germany.
Denmark <- getData('GADM', country = 'DNK', level = 0, path = './Data')
Sweden <- getData('GADM', country = 'SWE', level = 0, path = './Data')
Germany <- getData('GADM', country = 'DEU', level = 0, path = './Data')
# The maps above have the complete area of interest. You can crop the area of Sweden and Germany to only the space that is displayed in the extent of Denmark's map using the `crop()` function of the `raster` package
Sweden.2 <- crop(Sweden, extent(Denmark))
# Print the summary of Sweden.2
summary(Sweden.2)
Germany.2 <- crop(Germany, extent(Denmark))
# Print the summary of Germany.2
summary(Germany.2)
EU.LAEA <- "+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"
## Project the Weather station locations
DMI.DK.Shp.Proj <- spTransform(x = DMI.DK.Shp,
CRSobj = CRS(EU.LAEA))
## Project the Denmark Map
Denmark.Proj <- spTransform(x = Denmark,
CRSobj = CRS(EU.LAEA))
RMSE.Fnc <- function(observed, predicted) {
sqrt(mean((predicted - observed)^2,
na.rm = TRUE))
}
DMI.DK.Shp.Proj$Null.MAT <- mean(DMI.DK.Shp.Proj$MAT.C,
na.rm = T)
# Estimate the Root Mean Square Error for the NULL-MAT model using the RMSE.Fnc function created above
null.RMSE.MAT <- RMSE.Fnc(observed = DMI.DK.Shp.Proj$MAT.C,
predicted = DMI.DK.Shp.Proj$Null.MAT)
# Print the RMSE
null.RMSE.MAT
## Null TAP - Assign the mean across weather stations as the predicted TAP
DMI.DK.Shp.Proj$Null.TAP <- mean(DMI.DK.Shp.Proj$AnnPrec.mm.yr, na.rm = T)
# Estimate the Root Mean Square Error for the NULL-TAP model using the RMSE.Fnc function created above
null.RMSE.TAP <- RMSE.Fnc(observed = DMI.DK.Shp.Proj$AnnPrec.mm.yr,
predicted = DMI.DK.Shp.Proj$Null.TAP)
# Print the RMSE
null.RMSE.TAP
library(dismo)
## Build a voronoi of Nearest Neighbour polygons
NerNeiPoly <- voronoi(xy = DMI.DK.Shp.Proj) # SpatialPoints* object used to define the neighbourhoods - here
spplot(obj = NerNeiPoly,
zcol = 'MAT.C')
library(dismo)
## Build a voronoi of Nearest Neighbour polygons
NerNeiPoly <- voronoi(x = DMI.DK.Shp.Proj) # SpatialPoints* object used to define the neighbourhoods - here
spplot(obj = NerNeiPoly,
zcol = 'MAT.C')
plot(NerNeiPoly)
library(rgeos)
DK <- aggregate(Denmark.Proj)
## The function intersect adds the values of the Nearest Neighbour polygons to the aggregated polygon
NerNeiPolyCrop <- intersect(NerNeiPoly, DK)
## use the spplot function to plot the Nearest Neighbour polygons with the for Mean Annual Temperature
spplot(obj = NerNeiPolyCrop, # Define the object to plot.
zcol = 'MAT.C', # Define the variable to plot
col.regions = hcl.colors(n = 100, palette = "Blue-Red"),
main = c("Mean Annual Temperture (C)")
)
## use the spplot function to plot the Nearest Neighbour polygons with the Total Annual Precipitation
spplot(obj = NerNeiPolyCrop, # Define the object to plot.
zcol = 'AnnPrec.mm.yr', # Define the variable to plot
col.regions = hcl.colors(n = 100, palette = "RdBu"),
main = c("Total Annual Precipitation (mm)"))
DK.Rast100km <- raster(Denmark.Proj, res = 100000) # why 100000? because the units are m
DK.Rast10km <- raster(Denmark.Proj, res = 10000) #why 10000? because the units are m
DK.Rast1km <- raster(Denmark.Proj, res = 1000) # why 1000? because the units are m
NerNei.MAT.100km <- rasterize(x = NerNeiPolyCrop, # Spatial* object with the data to turn into a raster
y = DK.Rast100km, # The raster defining the resolution
field = 'MAT.C'  # The variable(s) to be transferred
)
NerNei.MAT.100km
Denmark.Proj
par(mar = c(2, 2, 4, 2))
# Plot the the shorelines of Denmark as a light grey
plot(Denmark.Proj,
col = "lightgrey", # make the continental areas light-grey
bg = "lightblue",
main = "Mean Annual Temperature (C)") # Make the oceans blue
# Add a bounding box
box()
# Define a sequence vector used to then specify the colour to use for each point
SortVect <- seq(min(DMI.DK.Shp.Proj$MAT.C, na.rm = T), # The min value for MAT
max(DMI.DK.Shp.Proj$MAT.C, na.rm = T), # The max value for MAT
length.out = 100 # Define how may end points for the intervals to generate
)
SortVect
# Define the colour to use for each point -  use the findInterval() function to do so.
# the findInterval() function finds the interval containing each element
Col.Use <- findInterval(x = DMI.DK.Shp.Proj$MAT.C, # Define the numeric vector to sort
vec = SortVect # Vector defining the start-end of each interval
)
Col.Use
# Define the colour based on a blue to red hcl palette
Col.Use <- hcl.colors(n = 100, palette = "Red-Blue")
# Plot the location
points(coordinates(DMI.DK.Shp.Proj),
pch = 19, cex = 2, col = Col.Use)
## legend
legend("topright",
fill =  hcl.colors(n = 5, palette = "Red-Blue"),
legend = round(seq(min(DMI.DK.Shp.Proj$MAT.C, na.rm = T),
max(DMI.DK.Shp.Proj$MAT.C, na.rm = T),
length.out = 5), 1),
title = "MAT (C)")
# Add some tick marks to define the latitude-longitude point
# Note that these commands are separated with a semicolon (this allows to put consecutive functions in one line)
axis(3, labels = NA); axis(4, labels = NA)
# Use the function degAxis() to draw axes on a plot using degree symbols in numbers
degAxis(1); degAxis(2)
# Create N-S and E-W grid lines over a geographic region using the function gridlines()
GrdLnObj <- gridlines(x = DMI.DK.Shp.Proj) # You need to define the object determining the spatial extent
# Add latitude and longitude lines as dashed lines
lines(GrdLnObj, # Define the object with the N-S and E-W grid lines
lty = 2 # Define the line type
)
# Create a gstat object for MAT
gs.MAT <- gstat(formula = MAT.C ~ 1, # Formula
# Note that NA values in DMI.DK.Shp.Proj has been removed as the interpolate function below doe not allow NA values
locations = DMI.DK.Shp.Proj[!is.na(DMI.DK.Shp.Proj$MAT.C), ],
# define the Neighbourhood (5 points)
nmax = 10,
# set the inverse distance power top Zero
set = list(idp = 0))
## The interpolate() function needs a raster template into which values are predicted - here you use the 1km Raster
IDW.MAT.1km <- interpolate(object = DK.Rast1km, # The raster template
model = gs.MAT # The gstat model
)
IDW.MAT.1km <- mask(x = IDW.MAT.1km,  # The IDW interpolated raster
mask = Denmark.Proj # The Spatial object used to "mask" the IDW interpolated raster
)
plot(IDW.MAT.1km, # The "masked" the IDW interpolated raster
col = hcl.colors(n = 100, palette = "Blue-Red"),
main = c("Mean Annual Temperature. (C)\nIDW results"))
library(automap)
# Generate the Experimental variogram model for MAT
MAT.Exp.Variog <-autofitVariogram(formula = MAT.C~1,
input_data = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
model = c("Sph", "Exp", "Gau", "Nug", "Lin"))
# Generate the Experim
library(automap)
MAT.Exp.Variog <-autofitVariogram(formula = MAT.C~1,
input_data = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
model = c("Sph", "Exp", "Gau", "Nug", "Lin"))
zerodist(DMI.DK.Shp.Proj)
## Remove duplicate points
DMI.DK.Shp.Proj2 <- DMI.DK.Shp.Proj[-zerodist(DMI.DK.Shp.Proj)[, 1], ]
## Test for Zero distance between points
zerodist(DMI.DK.Shp.Proj2)
MAT.Exp.Variog <-autofitVariogram(formula = MAT.C~1,
input_data = DMI.DK.Shp.Proj[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
model = c("Sph", "Exp", "Gau", "Nug", "Lin"))
MAT.Exp.Variog
zerodist(DMI.DK.Shp.Proj)
zerodist(DMI.DK.Shp.Proj)
zerodist(DMI.DK.Shp.Proj)
## Remove duplicate points
DMI.DK.Shp.Proj2 <- DMI.DK.Shp.Proj[-zerodist(DMI.DK.Shp.Proj)[, 1], ]
## Test for Zero distance between points
zerodist(DMI.DK.Shp.Proj2)
MAT.Exp.Variog <-autofitVariogram(formula = MAT.C~1,
input_data = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
model = c("Sph", "Exp", "Gau", "Nug", "Lin"))
MAT.Exp.Variog
plot(MAT.Variog,
MAT.Exp.Variog[[2]],
main = "MAT - Experimental Variogram")
MAT.Exp.Variog
plot(MAT.Variog,
MAT.Exp.Variog[[2]],
main = "MAT - Experimental Variogram")
# Generating a gstat for MAT
MAT.gstat <- gstat(formula = MAT.C~1,
locations = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ])
# Generating a variogram for MAT
MAT.Variog <- variogram(MAT.gstat,
# cut-off = spatial separation distance up to which point pairs are included
# Here 200000m (200km) as this the the distance until which most of the observations are
cutoff = 200000)
head(MAT.Variog)
plot(MAT.Variog)
plot(MAT.Variog,
MAT.Exp.Variog[[2]],
main = "MAT - Experimental Variogram")
DK.SpaGrid.1km <- raster(Denmark.Proj)
# Define the resolution of the raster
res(DK.SpaGrid.1km) <- 1000
# Ad values to facilitate the masking
DK.SpaGrid.1km[]<-1
# mask ocean
DK.SpaGrid.1km <- mask(DK.SpaGrid.1km,Denmark.Proj)
## transform to a Spatial grid
DK.SpaGrid.1km <- as(DK.SpaGrid.1km, 'SpatialGridDataFrame')
# Create a gstat object with the model, data and variogram
gstat.MAT <- gstat(formula = MAT.C~1,
locations = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
model = MAT.Exp.Variog[[2]])
# predicted values
Pred.gstat.MAT <- predict(object = gstat.MAT, # The gstat model (where the variogram is defined)
newdata = DK.SpaGrid.1km # a SpatialGrid dataset to make the predictions
)
## Plot the predicted values
spplot(obj = Pred.gstat.MAT,
zcol = "var1.pred",
col.regions = hcl.colors(n = 100, palette = "Blue-Red"),
main = 'Mean Annual Temperatiure (C)\nKriging result')
# use the krige function of gstat, that needs a  model, data, prediction space, and variogram
Pred.gstat.MAT<- krige(formula = AnnPrec.mm.yr~1,
locations = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
newdata = DK.SpaGrid.1km,
model = MAT.Exp.Variog[[2]])
head(Pred.gstat.MAT)
## Plot the predicted values
spplot(obj = Pred.gstat.MAT,
zcol = "var1.pred",
col.regions = hcl.colors(n = 100, palette = "RdBu"),
main = 'Mean Annual Temperatiure (C)\nKriging result')
Pred.gstat.MAT<- krige(formula = MAT.C~1,
locations = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
newdata = DK.SpaGrid.1km,
model = MAT.Exp.Variog[[2]])
head(Pred.gstat.MAT)
## Plot the predicted values
spplot(obj = Pred.gstat.MAT,
zcol = "var1.pred",
col.regions = hcl.colors(n = 100, palette = "RdBu"),
main = 'Mean Annual Temperatiure (C)\nKriging result')
Krig.MAT.Brick <- brick(Pred.gstat.MAT)
Krig.MAT.Brick
par(oma = c(0.5, 0.5, 2, 0.5))
plot(Krig.MAT.Brick,
main = c('Prediction Mean', "Prediction Variance"),
col = hcl.colors(n = 100, palette = "Blue-Red"))
mtext('Mean Annual Temperatiure (C)',
outer = T, cex = 1.2, font = 2)
Krig.MAT.Brick <- brick(Pred.gstat.MAT)
Krig.MAT.Brick
## Plot the Raster
par(oma = c(0.5, 0.5, 2, 0.5))
plot(Krig.MAT.Brick,
main = c('Prediction Mean', "Prediction Variance"),
col = hcl.colors(n = 100, palette = "RdBu"))
mtext('Mean Annual Temperatiure (C)', outer = T, cex = 1.2, font = 2)
Cros.Val.MAT<- krige.cv(formula = MAT.C~1,
locations = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
nfold = 5,  # Define the number of folds
model = MAT.Exp.Variog[[2]])
# Print the Cross-validation OBJECT
DMI.DK.Shp.Proj2
Cros.Val.MAT
RMSE.Kig.MAT <- sapply(1:5 , function(i){
RMSE.Fnc(observed = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ][Cros.Val.MAT$fold == i, ]$MAT.C,
predicted = Cros.Val.MAT$var1.pred[Cros.Val.MAT$fold == i])
})
# print the Root Mean Square Error for each fold
RMSE.Kig.MAT
mean(RMSE.Kig.MAT)
(RMSE.Kig.MAT.Imp <- (1 - (mean(RMSE.Kig.MAT) / null.RMSE.MAT)))
(RMSE.sum <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
# Relative Increase in MAT prediction performance when compared to the Null Model [null.RMSE.MAT]
MAT.Imp = c(RMSE.NeNe.MAT.Imp,
RMSE.IDW.MAT.Imp,
RMSE.TPS.MAT.Imp,
RMSE.Kig.MAT.Imp)
)
)
RMSE.sum
(RMSE.NeNe.MAT.Imp <- 1 - (mean(RMSE.NeNe.MAT) / null.RMSE.MAT))
RMSE.NeNe.MAT <- rep(NA, 5)
# Loop across the five k-folds
for (k in 1:5) {
# Create a Test Data.frame
test <- DMI.DK.Shp.Proj[kf == k, ]
# Create a Train Data.frame
train <- DMI.DK.Shp.Proj[kf != k, ]
# build a Nearest Neighbour predictions using Nearest Neighbour polygons
v <- voronoi(train)
# extract the expected values for each test site
p <- extract(v, test)
# Estimate the Root Mean Square Error for the evaluated cross fold
RMSE.NeNe.MAT[k] <- RMSE.Fnc(observed = test$MAT.C,
predicted = p$MAT.C)
}
kf <- kfold(x = DMI.DK.Shp.Proj, # The spatial object used to define the train/test dataset
k = 5 # Number of groups
)
## Build a vector to store the Root Mean Square Errors
RMSE.NeNe.MAT <- rep(NA, 5)
# Loop across the five k-folds
for (k in 1:5) {
# Create a Test Data.frame
test <- DMI.DK.Shp.Proj[kf == k, ]
# Create a Train Data.frame
train <- DMI.DK.Shp.Proj[kf != k, ]
# build a Nearest Neighbour predictions using Nearest Neighbour polygons
v <- voronoi(train)
# extract the expected values for each test site
p <- extract(v, test)
# Estimate the Root Mean Square Error for the evaluated cross fold
RMSE.NeNe.MAT[k] <- RMSE.Fnc(observed = test$MAT.C,
predicted = p$MAT.C)
}
# print the Root Mean Square Error for each fold
RMSE.NeNe.MAT
#The Mean Root Mean Square Error
mean(RMSE.NeNe.MAT)
## How much of an improvement over the null model is seen
(RMSE.NeNe.MAT.Imp <- 1 - (mean(RMSE.NeNe.MAT) / null.RMSE.MAT))
RMSE.sum <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
# Relative Increase in MAT prediction performance when compared to the Null Model [null.RMSE.MAT]
MAT.Imp = c(RMSE.NeNe.MAT.Imp,
RMSE.IDW.MAT.Imp,
RMSE.TPS.MAT.Imp,
RMSE.Kig.MAT.Imp)
)
RMSE.IDW.MAT <- rep(NA, 5)
# Loop across the five k-folds
for (k in 1:5) {
# Create a Test Data.frame
test <- DMI.DK.Shp.Proj[kf == k, ]
# Create a Train Data.frame
train <- DMI.DK.Shp.Proj[kf != k, ]
# build a gstat model for the interpolation
gs <- gstat(formula = MAT.C~1,
locations = train[!is.na(train$MAT.C), ],
# define the Neighbourhood (5 points)
nmax = 10,
# set the inverse distance power top Zero
set = list(idp = 0))
# Note that you can use the predict method to get predictions for the locations of the test points instead of generating new maps using interpolate
p <- predict(gs, test)
RMSE.IDW.MAT[k] <- RMSE.Fnc(test$MAT.C,
p$var1.pred)
}
# print the Root Mean Square Error for each fold
RMSE.IDW.MAT
#The Mean Root Mean Square Error
mean(RMSE.IDW.MAT)
## How much of an improvement over the null model is seen
(RMSE.IDW.MAT.Imp <- 1 - (mean(RMSE.IDW.MAT) / null.RMSE.MAT))
RMSE.TPS.MAT.Imp
## Evaluate with 5-fold cross validation for MAT.
set.seed(5132015)
# using the `kfold()` function of the package `dismo` each observation is placed into a cross validation fold.
kf <- kfold(x = DMI.DK.Shp.Proj, # The spatial object used to define the train/test dataset
k = 5 # Number of groups
)
## Build a vector to store the Root Mean Square Errors
RMSE.TPS.MAT <- rep(NA, 5)
# Loop across the five k-folds
for (k in 1:5) {
# Create a Test Data.frame
test <- DMI.DK.Shp.Proj[kf == k, ]
# Create a Train Data.frame
train <- DMI.DK.Shp.Proj[kf != k, ]
# build a Tps model for the interpolation
Tps.mod <- Tps(x = coordinates(train), # Matrix of locations
Y = train$MAT.C # Vector of response variables on the locations
)
# Note that you can use the predict method to get predictions for the locations of the test points instead of generating new maps using interpolate
p <- predict(Tps.mod, coordinates(test))
RMSE.TPS.MAT[k] <- RMSE.Fnc(test$MAT.C,
p)
}
# print the Root Mean Square Error for each fold
RMSE.TPS.MAT
#The Mean Root Mean Square Error
mean(RMSE.TPS.MAT)
## How much of an improvement over the null model is seen
(RMSE.TPS.MAT.Imp <- 1 - (mean(RMSE.TPS.MAT) / null.RMSE.MAT))
### MAT Kriging Cross-validation
Cros.Val.MAT<- krige.cv(formula = MAT.C~1,
locations = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ],
nfold = 5,  # Define the number of folds
model = MAT.Exp.Variog[[2]])
# Print the Cross-validation OBJECT
Cros.Val.MAT
# Estimate the RMSE for each of the Cross-validated fold
RMSE.Kig.MAT <- sapply(1:5 , function(i){
RMSE.Fnc(observed = DMI.DK.Shp.Proj2[!is.na(DMI.DK.Shp.Proj2$MAT.C), ][Cros.Val.MAT$fold == i, ]$MAT.C,
predicted = Cros.Val.MAT$var1.pred[Cros.Val.MAT$fold == i])
})
# print the Root Mean Square Error for each fold
RMSE.Kig.MAT
#The Mean Root Mean Square Error
mean(RMSE.Kig.MAT)
## How much of an improvement over the null model is seen
(RMSE.Kig.MAT.Imp <- (1 - (mean(RMSE.Kig.MAT) / null.RMSE.MAT)))
RMSE.sum <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
# Relative Increase in MAT prediction performance when compared to the Null Model [null.RMSE.MAT]
MAT.Imp = c(RMSE.NeNe.MAT.Imp,
RMSE.IDW.MAT.Imp,
RMSE.TPS.MAT.Imp,
RMSE.Kig.MAT.Imp)
)
RMSE.sum
RMSE.w <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
MAT.RMSE = c(mean(RMSE.NeNe.MAT),
mean(RMSE.IDW.MAT),
mean(RMSE.TPS.MAT),
mean(RMSE.Kig.MAT)))
RMSE.w[, 2]
apply(RMSE.w[, 2], 2, function(x){x/sum(x)})
apply(RMSE.w[, 2], 2, function(x){x/sum(x)}
apply(RMSE.w[, 2], 2, function(x){x/sum(x)})
RMSE.w <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
W RMSE.w[, 2]/sum(RMSE.w[, 2]))
RMSE.w <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
W = RMSE.w[, 2]/sum(RMSE.w[, 2]))
RMSE.w
MAT.Stack <- stack(NerNei.MAT.1km,
IDW.MAT.1km,
TPS.MAT.Pred,
# the 1 subscript is to only extract the predictions
Krig.MAT.Brick[[1]])
MAT.Stack <- stack(NerNei.MAT.1km,
IDW.MAT.1km,
TPS.MAT.Pred,
# the 1 subscript is to only extract the predictions
Krig.MAT.Brick[[1]])
NerNei.MAT.1km
NerNei.MAT.1km <- rasterize(x = NerNeiPolyCrop['MAT.C'],  # Spatial* object with the data to turn into a raster
y = DK.Rast1km, # The raster defining the resolution
field = 'MAT.C'# The variable(s) to be transferred
)
IDW.MAT.1km
TPS.MAT.Pred
library(fields)
# Estimate a thin plate spline model for MAT
# Build the thin plate model
TPS.MAT <- Tps(x = coordinates(DMI.DK.Shp.Proj), # Matrix of independent variables
Y = DMI.DK.Shp.Proj$MAT.C # Vector of dependent variables
)
TPS.MAT
# Generate a prediction of the model using the `interpolate()` function from the raster package.
TPS.MAT.Pred <- interpolate(object = raster(DK.SpaGrid.1km), # Baseline Raster* object.
model = TPS.MAT # The TPS model to generate new predictions.
)
# Mask out all the areas outside the landmass of Denmark
TPS.MAT.Pred <- mask(x = TPS.MAT.Pred, # The interpolated raster
mask = Denmark.Proj # An spatial object to crop the oceans.
)
Krig.MAT.Brick
MAT.Stack <- stack(NerNei.MAT.1km,
IDW.MAT.1km,
TPS.MAT.Pred,
# the 1 subscript is to only extract the predictions
Krig.MAT.Brick[[1]])
names(MAT.Stack) <- c("NerNei", "IDW" , "TPS", "Krig")
MAT.Stack
MAT.Ensembl <- sum(MAT.Stack*RMSE.w$MAT.RMSE)
MAT.Ensembl <- sum(MAT.Stack*RMSE.w$MAT.RMSE)
MAT.RMSE
RMSE.w <- data.frame(Model = c("Nearest Neighbour", "IDW", "TPS", "OK"),
MAT.RMSE = RMSE.w[, 2]/sum(RMSE.w[, 2]))
RMSE.w
MAT.Ensembl <- sum(MAT.Stack*RMSE.w$MAT.RMSE)
plot(MAT.Ensembl,
col = hcl.colors(n = 100, palette = "Blue-Red"),
main = c('Mean Annual Temperatiure (C)\n Ensemble result'))
MAT.Stack <-stack(MAT.Stack, MAT.Ensembl)
names(MAT.Stack)[5] <- "Ensemble"
plot(MAT.Stack,
col = hcl.colors(n = 100, palette = "Blue-Red"))
Denmark <- getData('GADM', country = 'DNK', level = 0, path = './Data')
summary(Denmark)
library(raster)
# Get the country administrative boundaries for Denmark, Sweden, and Germany.
Denmark <- getData('GADM', country = 'DNK', level = 0, path = './Data')
# Print the summary of Sweden.2
summary(Denmark)
# Plot the location of all the Weather stations
plot(DMI.DK.Shp,
pch = 19, cex = 0.5, col = "red")
# Plot the World map
plot(Denmark, add = T)
# Add a bounding box and some tick marks to define the latitude-longitude point
box(); axis(1, labels = NA); axis(2, labels = NA);  axis(3, labels = NA); axis(4, labels = NA)
libray(gstat)
library(gstat)
