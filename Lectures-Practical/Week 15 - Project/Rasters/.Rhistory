nlcd2011a <- ratify(x = nlcd2011)
levels(nlcd2011)
levels(nlcd2011a)
rat <- levels(nlcd2011a)[[1]]
rat$landcover <- nlcdclass
rat
levels(nlcd2011a) <- rat
levels(nlcd2011a)
plot(nlcd2011a)
rat
nlcd2011a
nlcdclass
plt <- levelplot(nlcd2011a,
col.regions = classcolor,
main = 'Distribution of Training Sites')
library(rasterVis) # rasterVis offers more advanced (trellis/lattice) plotting of Raster* objects. Please install the package if it is not available for your machine.
plt <- levelplot(nlcd2011a,
col.regions = classcolor,
main = 'Distribution of Training Sites')
print(plt + layer(sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1)))
plt <- levelplot(nlcd2011a,
col.regions = classcolor,
main = 'Distribution of Training Sites')
print(plt)
?levelplot
rasterVis::levelplot(x = nlcd2011a)
rasterVis::levelplot(x = nlcd2011a, # Raster to plot?
col.regions = classcolor, # Use the classcolor vector to define the colours.
main = 'Land Cover Clasifiction' # Main Title
)
?sampleStratified
set.seed(99)
# Sampling
samp2011 <- sampleStratified(x = nlcd2011s, # Raster to be "sampled"
size = 200, # Number of samples per class
na.rm = TRUE, # NA values are removed from random sample?
sp = TRUE # Output as a SpatialPointsDataFrame?
)
samp2011
set.seed(99)
# Sampling
samp2011 <- sampleStratified(x = nlcd2011s, # Raster to be "sampled"
size = 200, # Number of samples per class
na.rm = TRUE, # NA values are removed from random sample?
sp = TRUE # Output as a SpatialPointsDataFrame?
)
samp2011 <- sampleStratified(x = nlcd2011a, # Raster to be "sampled"
size = 200, # Number of samples per class
na.rm = TRUE, # NA values are removed from random sample?
sp = TRUE # Output as a SpatialPointsDataFrame?
)
samp2011
table(nlcd2011a)
table(nlcd2011a[])
rm(list=ls());gc()
URL.Loc <- "https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/nlcd-L1.tif"
URL.Loc <- "https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/nlcd-L1.tif"
nlcd <- brick(URL.Loc)
# Give the right names to the nlcd bands
names(nlcd) <- c("nlcd2001", "nlcd2011")
nlcd <- brick(URL.Loc)
nlcd <- brick(URL.Loc)
URL.Loc <- "/Users/alejandroordonez/Dropbox/Courses_&_Conferences/2021/Courses/Statistical and Geospatial Modeling/Lectures-Practical/11. Regression trees [Week 45]/Practical/Data/centralvalley/nlcd-L1.tif"
# Use `brick()` to load the file and save it as an object named landsat5.
#The principal difference between `RasterBrick` and `RasterStack` objects is that RasterBricks can only be linked to a single (multi-layer) file. In contrast, a RasterStacks can be formed from separate files and/or from a few layers (‘bands’) from a single file.
nlcd <- brick(URL.Loc)
# Give the right names to the nlcd bands
names(nlcd) <- c("nlcd2001", "nlcd2011")
URL.Loc <- "/Users/alejandroordonez/Dropbox/Courses_&_Conferences/2021/Courses/Statistical and Geospatial Modeling/Lectures-Practical/11. Regression trees [Week 45]/Practical/Data/centralvalley/centralvalley-2011LT5.tif"
# Use `stack()` to load the file and save it as an object named landsat5.
landsat5 <- stack(URL.Loc)
# Print the output of the landsat5 object.
landsat5
par(mfrow = c(1, 2))
# Use the plotRGB() function with a linear stretch to make the true colour composites - these follow an RGB order
plotRGB(landsat5[[c(3, 2, 1)]],# True colour composites flow a RGB order.
r = 1, g = 2, b = 3, # Define which band is red, green, and blue.
scale = 1, # defined the maximum value a band can take (used to scaling when colouring).
main="Landsat True Color Composite\nlin stretch", # add a title to the figure.
stretch="lin", # How to stretch the values to increase the contrast?
margins = TRUE
)
# Use the plotRGB() function with a linear stretch to make the false colour composites - these follow an RGB order
plotRGB(landsat5[[c(4,3,2)]],# True colour composites flow an RGB order.
r = 1, g = 2, b = 3, # Define which band is red, green, and blue.
scale = 1, # defined the maximum value a band can take (used to scaling when colouring).
main="Landsat False Color Composite\nlin stretch", # add a title to the figure.
stretch="lin", # How to stretch the values to increase the contrast?
margins = TRUE
)
NDVI <- (landsat5[[4]] - landsat5[[3]])/(landsat5[[4]] + landsat5[[3]])
# Using the function `getValues()` extract the values in the `NDVI` into an object named NDVIVctv.
NDVIVct <- getValues(NDVI)
str(NDVIVct)
# Set the random number generator to reproduce the results
set.seed(99)
# Impalement the kmeans() function with the criteria defined in the task:
# you want to create eigth clusters, allow 1000 iterations, use ten random sets, and use "Lloyd" method
kmncluster <- kmeans(x = na.omit(NDVIVct), # numeric matrix of data to classify.
centers = 8, #How many clusters?
iter.max = 1000, # Which is the maximum number of iterations allowed?
nstart = 10, # How many random sets should be chosen?
algorithm ="Lloyd" # Which algorithm to use when looking at the optimal solution.
)
str(kmncluster) # kmeans returns an object of class "kmeans"
# Use the ndvi object to set the cluster values to a new raster
ReClassNDVI <- setValues(NDVI, kmncluster$cluster)
#Plot the k-means classified NDVI using a highly contrasting colour scheme.
plot(ReClassNDVI, # The k-means RasterLayer.
main = "Unsupervised classification\n K-means 8-class classifiction", # Main title.
col = c("#7fc97f", "#beaed4", "#fdc086", "#ffff99", "#386cb0", "#f0027f", "#bf5b17", "#666666") # A contrasting colour scheme.
)
nlcd <- brick(URL.Loc)
# Give the right names to the nlcd bands
names(nlcd) <- c("nlcd2001", "nlcd2011")
URL.Loc <- "/Users/alejandroordonez/Dropbox/Courses_&_Conferences/2021/Courses/Statistical and Geospatial Modeling/Lectures-Practical/11. Regression trees [Week 45]/Practical/Data/centralvalley/nlcd-L1.tif"
# Use `brick()` to load the file and save it as an object named landsat5.
#The principal difference between `RasterBrick` and `RasterStack` objects is that RasterBricks can only be linked to a single (multi-layer) file. In contrast, a RasterStacks can be formed from separate files and/or from a few layers (‘bands’) from a single file.
nlcd <- brick(URL.Loc)
# Give the right names to the nlcd bands
names(nlcd) <- c("nlcd2001", "nlcd2011")
plot(x = nlcd, # raster to plot.
col = sample(hcl.colors(9, palette = "Zissou")) # Define the colour ramp
)
# The class names  for plotting
nlcdclass <- c("Water", "Developed", "Forest", "Herbaceous", "Planted/Cultivated", "Wetlands")
# Hex codes of colours
classcolor <- c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C", "#D1D182", "#FBF65D", "#C8E6F8")
#Note from the table above that there is no class with value 6
classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.
classnames1 = nlcdclass, # Class Name.
classcolor # Class Colour.
)
nlcdclass <- c("Water", "Developed", "Barren", "Forest", "Shrubland", "Herbaceous", "Planted/Cultivated", "Wetlands")
# Hex codes of colours
classcolor <- c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C", "#D1D182", "#FBF65D", "#C8E6F8")
classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.
classnames1 = nlcdclass, # Class Name.
classcolor # Class Colour.
)
nlcdclass <- c("Water", "Developed", "Barren", "Forest", "Shrubland", "Herbaceous", "Planted/Cultivated", "Wetlands")
# Hex codes of colours
classcolor <- c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C", "#D1D182", "#FBF65D", "#C8E6F8")
#Note from the table above that there is no class with value 6
classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.
classnames1 = nlcdclass, # Class Name.
classcolor # Class Colour.
)
nlcd2011 <- nlcd[[2]] # OR nlcd[["nlcd2011"]]
# Re-define the ncld2011 RasterLayer as a categorical variable using the ratify function.
nlcd2011a <- ratify(x = nlcd2011)
## Now define the levels for each value in the ratified RasterLayer
# Create a data.frame with the Raster levels and the Names
rat <- data.frame(ID = levels(nlcd2011a)[[1]], # The ratified raster attributes values.
landcover = nlcdclass # The name-string for each class
)
# Attach the attributes lookup table data.frame (rat) as the levels of the ratified raster.
levels(nlcd2011a) <- rat
# Plot the The ratified raster
rasterVis::levelplot(x = nlcd2011a, # Raster to plot?
col.regions = classcolor, # Use the classcolor vector to define the colours.
main = 'Land Cover Clasifiction' # Main Title
)
set.seed(99)
# Sampling
samp2011 <- sampleStratified(x = nlcd2011a, # Raster to be "sampled"
size = 200, # Number of samples per class
na.rm = TRUE, # NA values are removed from random sample?
sp = TRUE # Output as a SpatialPointsDataFrame?
)
samp2011
plot(nlcd2011a,
main = "Land cover classification 2011",
col = classcolor)
image(nlcd2011a,
main = "Land cover classification 2011",
col = classcolor)
image(nlcd2011a,
main = "Land cover classification 2011",
col = classcolor)
plot(samp2011,
pch = 10,
add = T)
classcolor
image(nlcd2011,
main = "Land cover classification 2011",
col = classcolor)
rasterVis::levelplot(x = nlcd2011a, # Raster to plot?
col.regions = classcolor, # Use the classcolor vector to define the colours.
main = 'Land Cover Clasifiction' # Main Title
)
plot(samp2011,
pch = 10,
add = T)
image(nlcd2011a,
main = "Land cover classification 2011",
col = classcolor)
# Add the sampled points over the land cover raster
plot(samp2011,
pch = 10,
add = T)
nlcd2011a
image(nlcd2011,
main = "Land cover classification 2011",
col = classcolor)
nlcd2011
classcolor
image(nlcd2011a,
main = "Land cover classification 2011",
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
points(samp2011, # The SpatialPointsDataFrame to plot
pch = 10)
?levelplot
plot(plt)
print(plt)
plt <- levelplot(nlcd2011a,
col.regions = classcolor,
main = 'Distribution of Training Sites')
print(plt)
plot(plt)
plot(plt)
plot(plt + layer(sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1)))
rasterVis::levelplot(x = nlcd2011a, # Raster to plot?
col.regions = classcolor, # Use the classcolor vector to define the colours.
main = 'Land Cover Clasifiction' # Main Title
)
axis(1)
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
par(mar=c(3,3,4,7))
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
legend("topright",
fill= classcolor,
legend  = nlcdclass)
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
legend("topright",
fill= classcolor,
legend  = nlcdclass,
bg="n")
?legend
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
legend("topright",
fill= classcolor,
legend  = nlcdclass,
bty="n")
legend("topright",
inset = c(1,0),
fill= classcolor,
legend  = nlcdclass,
bty="n")
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
legend("topright",
inset = c(1,0),
fill= classcolor,
legend  = nlcdclass,
bty="n")
legend("topright",
inset = c(1,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.5,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.05,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.1,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(0.1,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.5,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.25,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.3,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
legend("topright",
inset = c(-0.4,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
xpd=NA)
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
legend("topright",
inset = c(-0.4,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
cex = 0.7,
xpd=NA)
legend("topright",
inset = c(-0.2,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
cex = 0.7,
xpd=NA)
legend("topright",
inset = c(-0.3,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
cex = 0.7,
xpd=NA)
legend("topright",
inset = c(-0.25,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
cex = 0.7,
xpd=NA)
par(mar=c(3,3,4,7))
image(nlcd2011a,
main = "Land cover classification 2011", # Give the Name
col = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C",NA, "#D1D182", "#FBF65D", "#C8E6F8"))
legend("topright",
inset = c(-0.25,0),
fill= classcolor,
legend  = nlcdclass,
bty="n",
cex = 0.7,
xpd=NA)
layer(sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1))
plot(layer(sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1)))
```
?layer
?sp.points
PntLyr <- sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1)
PntLyr <- sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1)
PntLyr <- sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1)
PntLyr <- layer(sp.points(samp2011,
pch = 3,
cex = 0.5,
col = 1))
plt <- levelplot(nlcd2011a,
col.regions = classcolor,
main = 'Distribution of Training Sites')
plot(plt + PntLyr)
?layer
?sp.points
# Tabulate the number of land cover classes sampled by the `sampleStratified` function
table(samp2011$nlcd2011)
?extract
samp2011@data$nlcd2011
# Extract the values from `landsat5`
sampvals <- extract(x = landsat5, # Define the raster to be samples.
y = samp2011, # Define the spatial vector data with the locations to sample.
df = TRUE # Returne the results as a data.frame?
)
# sampvals no longer has the spatial information!!. To keep the spatial information, you use `sp = TRUE` argument in the `extract` function.
# drop the ID column
sampvals <- sampvals[, -1]
# combine the class information with extracted values
sampdata <- data.frame(classvalue = samp2011@data$nlcd2011, # Get the Landcover "class" for each selected loction.
sampvals # The data.frame with the hiper-spectral bands in `landsat5`
)
head(sampdata)
?list
?princomp
?prcomp
prcomp(USArrests, scale. = TRUE)
summary(prcomp(USArrests, scale. = TRUE))
summary(prcomp(USArrests, scale. = TRUE))$importance
?rpart
??
rpart
# Load the required package (rpart)
library(rpart)
?rpart
?rpart
CART.colsums
?predict.raster
?predict
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = FALSE, warning = FALSE, tidy='styler', tidy.opts=list(strict=TRUE), fig.width = 10, fig.height = 10, fig.align = "center")
options(width = 200)
Bigfoot.URL <- "https://opendata.arcgis.com/datasets/9947fc49e6c44120b4a1b3133c073dbc_0.csv"
Bigfoot.dta <- read.csv(Bigfoot.URL)
head(Bigfoot.dta)
data(wrld_simpl)
# Showing the type of object and info in it
summary(wrld_simpl)
# Variable names
names(wrld_simpl)
# The first 5 rows of the Data matrix
head(wrld_simpl@data)
# plot the `SpatialPolygonsDataFrame`
plot(wrld_simpl)
require(raster)
Out.Dir <- "~/Dropbox/Aarhus Assistant Professor/Projects/4. PopulationDensity-LGMtoNow/Data/PodDenPred/CentenialAverages/0. CrossVal/"
r<- raster(paste0(Out.Dir,"PopDensity/",8,"kaBP.tif"))
r[r[]<1]<-NA
dev.new()
plot(log(r), legend.only=TRUE, col=hcl.colors(100, palette = "Roma"),
zlim=c(0,2.7),
legend.width=2,
axis.args=list(at=log(seq(1,15,by=3)),
labels=seq(1,15,by=3),
cex.axis=1),
legend.args=list(text='Population size \n[ind/100km2]', side=4, font=2, line=4, cex=1.5),
smallplot=c(0.01,.09, .3,.75))
rm(list=ls());gc()
require(raster)
setwd("~/Dropbox/Courses_&_Conferences/2021/Courses/Statistical and Geospatial Modeling/Lectures-Practical/14-15. Project/Data/Rasters")
# Species richness
DK.Rich <- raster("./1. Species dataset/DK.Rich.tif")
DK.SampDensity <- raster("./1. Species dataset/DK.SampDensity.tif")
DK.WintMinTemp <- raster("./2. Climate/DK_BIO11-CHELSA.tif")/10
Rich <- DK.Rich
SampDensity <- DK.SampDensity
WintMinTemp <- DK.WintMinTemp
#Rich <- aggregate(DK.Rich,2,mean)
#SampDensity <- aggregate(DK.SampDensity,2,mean)
#WintMinTemp <- aggregate(DK.WintMinTemp,2,mean)
# Build a Data frame for the evaluated response (Denisty spp/km2), predictors (Wintter minimum temperture - C), and auxilary varibles (Sample denisty - No of Obs/km2, Position - Northling/Eastling)
DK.Dbs <- data.frame(SppDensity = Rich[],
WintMinTemp = WintMinTemp[],
SampDensity = SampDensity[],
Northling = coordinates(Rich)[,"y"],
Eastling  = coordinates(Rich)[,"x"])
DK.Dbs <- DK.Dbs[complete.cases(DK.Dbs),]
requre(nlme)
require(nlme)
lm.model.3a <- lme(log(SppDensity) ~ WintMinTemp,
random = ~ 1 | SampDensity,
correlation = corExp(form=~ Eastling + Northling, nugget=TRUE),
data = DK.Dbs,
control = lmeControl(opt = "optim"))
DK.Dbs <- DK.Dbs[c(DK.Dbs$SppDensity>100),]
lm.model.3a <- lme(log(SppDensity) ~ WintMinTemp,
random = ~ 1 | SampDensity,
correlation = corExp(form=~ Eastling + Northling, nugget=TRUE),
data = DK.Dbs,
control = lmeControl(opt = "optim"))
1-(-2*logLik(lm.model.2a))/(-2*logLik(update(lm.model.2a,.~-WintMinTemp)))
1-(-2*logLik(lm.model.3a))/(-2*logLik(update(lm.model.3a,.~-WintMinTemp)))
m.model.3aNull<- update(lm.model.3a,.~-WintMinTemp)
lm.model.3aNull<- m.model.3aNull
logLik(lm.model.3a)
as.numeric(logLik(lm.model.3a))
as.numeric(logLik(lm.model.3aNull))
abs(as.numeric(logLik(lm.model.3a))-as.numeric(logLik(lm.model.3aNull)))
abs(as.numeric(logLik(lm.model.3a))-as.numeric(logLik(lm.model.3aNull)))/as.numeric(logLik(lm.model.3aNull))
1-abs(as.numeric(logLik(lm.model.3a))-as.numeric(logLik(lm.model.3aNull)))/as.numeric(logLik(lm.model.3aNull))
1-(as.numeric(logLik(lm.model.3a))/as.numeric(logLik(lm.model.3aNull)))
(1-(as.numeric(logLik(lm.model.3a))-as.numeric(logLik(lm.model.3aNull))))
(1-as.numeric(logLik(lm.model.3aNull)))
(1-(as.numeric(logLik(lm.model.3a))-as.numeric(logLik(lm.model.3aNull))))/(1-as.numeric(logLik(lm.model.3aNull)))
1-abs(-2*logLik(lm.model.3a))/(-2*logLik(update(lm.model.3a,.~-WintMinTemp)))
1-abs((-2*logLik(lm.model.3a))/(-2*logLik(lm.model.3aNull)))
