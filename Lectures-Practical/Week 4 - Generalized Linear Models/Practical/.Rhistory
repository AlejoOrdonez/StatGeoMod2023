Tol.Summ <- rep(x = NA,
times = length(PredNames))
# give names to each place in the vector using PredNames
names(Tol.Summ) <- PredNames
for (i in PredNames){
# Create new data.frame named Tol.DF was the first variable tested.
Tol.DF <- data.frame(Pred = DK.Biodiv[,i], # the data of the predictor variable being tested should be included here  - call it using the i iterator.
DK.Biodiv[,PredNames[!PredNames%in%i]])# Add the other predictor variables here. For this, use the logical test !PredNames%in%i (each select all predictors variable EXECEPT i).
# Build an lm model to predict the predictor of interest as a function of all other predictors. Save this model as Tol.LM.
Tol.LM <- lm(Pred~.,
data = Tol.DF)
# To estimate the tolerance for the predictor of interest, the first step is to extract the R2 from the regression model and store it as an object name Tol.R2
Tol.R2 <- summary(Tol.LM)$r.squared #
# estimate the tolerance (1-R2) and save it in the corresponding position of the Tol.Summ you created before the loop.
Tol.Summ[i] <- 1 - Tol.R2
}
Tol.Summ
Tol.Summ
Tol.Summ <- rep(x = NA,
times = length(PredNames))
# give names to each place in the vector using PredNames
names(Tol.Summ) <- PredNames
PredNames
for (i in PredNames){
# Create new data.frame named Tol.DF was the first variable tested.
Tol.DF <- data.frame(Pred = DK.Biodiv[,i], # the data of the predictor variable being tested should be included here  - call it using the i iterator.
DK.Biodiv[,PredNames[!PredNames%in%i]])# Add the other predictor variables here. For this, use the logical test !PredNames%in%i (each select all predictors variable EXECEPT i).
# Build an lm model to predict the predictor of interest as a function of all other predictors. Save this model as Tol.LM.
Tol.LM <- lm(Pred~.,
data = Tol.DF)
# To estimate the tolerance for the predictor of interest, the first step is to extract the R2 from the regression model and store it as an object name Tol.R2
Tol.R2 <- summary(Tol.LM)$r.squared #
# estimate the tolerance (1-R2) and save it in the corresponding position of the Tol.Summ you created before the loop.
Tol.Summ[i] <- 1 - Tol.R2
}
PredNames
i
Tol.DF <- data.frame(Pred = DK.Biodiv[,i], # the data of the predictor variable being tested should be included here  - call it using the i iterator.
DK.Biodiv[,PredNames[!PredNames%in%i]])# Add the other predictor va
Tol.DF
DK.Biodiv
DK.Biodiv
!PredNames%in%i
PredNames[!PredNames%in%i]
Tol.DF <- data.frame(Pred = DK.Biodiv[,i], # the data of the predictor variable being tested should be included here  - call it using the i iterator.
DK.Biodiv[,PredNames[!PredNames%in%i]])#
Tol.LM <- lm(Pred~.,
data = Tol.DF)
Tol.R2 <- summary(Tol.LM)$r.squared
Tol.Summ[i] <- 1 - Tol.R2
for (i in PredNames){
# Create new data.frame named Tol.DF was the first variable tested.
Tol.DF <- data.frame(Pred = DK.Biodiv[,i], # the data of the predictor variable being tested should be included here  - call it using the i iterator.
DK.Biodiv[,PredNames[!PredNames%in%i]])# Add the other predictor variables here. For this, use the logical test !PredNames%in%i (each select all predictors variable EXECEPT i).
# Build an lm model to predict the predictor of interest as a function of all other predictors. Save this model as Tol.LM.
Tol.LM <- lm(Pred~.,
data = Tol.DF)
# To estimate the tolerance for the predictor of interest, the first step is to extract the R2 from the regression model and store it as an object name Tol.R2
Tol.R2 <- summary(Tol.LM)$r.squared #
# estimate the tolerance (1-R2) and save it in the corresponding position of the Tol.Summ you created before the loop.
Tol.Summ[i] <- 1 - Tol.R2
}
(i<-PredNames[1])
Tol.Summ <- rep(x = NA,
times = length(PredNames))
DK.Biodiv <-  read.csv("Data/Biowide_AllSppRich.csv")
PredNames <- names(DK.Biodiv)[-c(1,4:6)]
PredNames
names(DK.Biodiv)
DK.Biodiv <-  read.csv("Data/Biowide_AllSppRich.csv")
names(DK.Biodiv)[-c(1,4:6)]
DK.Biodiv <-  read.csv("data/Biowide_With_EnvDta.csv")
head(DK.Biodiv)
dir("data/")
head(read.csv("data/Biowide_AllSppRich.csv"")
head(read.csv("data/Biowide_AllSppRich.csv")
)
DK.Biodiv <-  read.csv("data/Biowide_AllSppRich.csv")
# Use the function head to print the five forst rows
head(DK.Biodiv)
names(DK.Biodiv)
require(raster)
?getData()
DK.Biodiv <-  read.csv("data/Biowide_With_EnvDta.csv")
# Use the function head to print the five forst rows
head(DK.Biodiv)
boxplot(DK.Biodiv$NatDensBasMp,
main = "distance (meters) of the fragment")
par(mfrow=c(2,3))
# Box plot for Nature Density
boxplot(DK.Biodiv$NatDensBasMp,
main = "Nature Density")
# Box plot for Distance to coast
boxplot(DK.Biodiv$NatDensBasMp,
main = "Distance to coast")
# Box plot for Human Impact Index
boxplot(DK.Biodiv$HII,
main = "Human Impact Index")
# Box plot for Slope
boxplot(DK.Biodiv$Slope30mAgg,
main = "Slope")
# Box plot for Precipitation Seasonality
boxplot(DK.Biodiv$PrecSea,
main = "Precipitation Seasonality")
Cor.pred.DK.Biodiv <- cor(DK.Biodiv[, c("DISTX", "AGE", "PERSHRUB")],
method = "spearman")
Cor.pred.DK.Biodiv <- cor(DK.Biodiv[, c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")],
method = "spearman")
Cor.pred.DK.Biodiv
getwd()
DK.Biodiv[, c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")]
DK.Biodiv <-  read.csv("data/Biowide_AllSppRich.csv")
head(DK.Biodiv)
Cor.pred.DK.Biodiv <- cor(DK.Biodiv[, c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")],
method = "spearman")
#Call the Cor.pred.DK.Biodiv object
Cor.pred.DK.Biodiv
image(Cor.pred.DK.Biodiv)
plot(raster(Cor.pred.DK.Biodiv))
image(Cor.pred.DK.Biodiv, zlim=c(-1,1))
hcl.colors(100,"RdYlBl")
hcl.colors(100,"RdYlBlu")
?hcl.colors
hcl.swatch <- function(type = NULL, n = 5, nrow = 11,
border = if (n < 15) "black" else NA) {
palette <- hcl.pals(type)
cols <- sapply(palette, hcl.colors, n = n)
ncol <- ncol(cols)
nswatch <- min(ncol, nrow)
par(mar = rep(0.1, 4),
mfrow = c(1, min(5, ceiling(ncol/nrow))),
pin = c(1, 0.5 * nswatch),
cex = 0.7)
while (length(palette)) {
subset <- 1:min(nrow, ncol(cols))
plot.new()
plot.window(c(0, n), c(0, nrow + 1))
text(0, rev(subset) + 0.1, palette[subset], adj = c(0, 0))
y <- rep(subset, each = n)
rect(rep(0:(n-1), n), rev(y), rep(1:n, n), rev(y) - 0.5,
col = cols[, subset], border = border)
palette <- palette[-subset]
cols <- cols[, -subset, drop = FALSE]
}
par(mfrow = c(1, 1), mar = c(5.1, 4.1, 4.1, 2.1), cex = 1)
}
hcl.swatch("diverging")
hcl.swatch("divergingx")
image(Cor.pred.DK.Biodiv,
zlim=c(-1,1),
col = hcl.colors(100,"RdYlBu"))
legend(grconvertX(0.5, "device"), grconvertY(1, "device"),
c("0",".5","1"), fill = colMap[c(1, 10, 20)], xpd = NA)
legend(grconvertX(0.5, "device"), grconvertY(1, "device"),
c("0",".5","1"), fill = hcl.colors(100,"RdYlBu"), xpd = NA)
fields::image.plot(Cor.pred.DK.Biodiv)
fields::image.plot(Cor.pred.DK.Biodiv,
zlim=c(-1,1), # Sets the range of values to get colors from between -1 and1
col = hcl.colors(100,"RdYlBu") # sets the colors to a Red-Yellow-Blue Palette.
)
Cor.pred.DK.Biodiv
abs(Cor.pred.DK.Biodiv)
range(Cor.pred.DK.Biodiv)
diag(Cor.pred.DK.Biodiv)
diag(Cor.pred.DK.Biodiv) <- NA
Cor.pred.DK.Biodiv
range(Cor.pred.DK.Biodiv,na.rm=T)
DK.Biodiv
??vif
names(DK.Biodiv)
COlin.Model <- lm(Log.S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea,
data = DK.Biodiv)
car::vif(mod = Colin.Model)
Colin.Model <- lm(Log.S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea,
data = DK.Biodiv)
# Use a the function `vif()` of the `car` package to estimate the variance inflation index.
car::vif(mod = Colin.Model)
1/Colin.DK.Pred
Colin.DK.Pred <- car::vif(mod = Colin.Model) #
# Call the Colin.DK.Pred object
Colin.DK.Pred
# Estimating each predictor tolerance (1/vif)
1/Colin.DK.Pred
1/0.1
?linear
?line
Var
Var<-"NatDensBasMp"
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19) # make the points filled circles
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
abline(Reg.Tmp, ## the lm object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
Reg.Tmp
coef(Reg.Tmp)
coef(Reg.Tmp)[2]
legend("topright",
legend = round(coef(Reg.Tmp)[2]))
cor.test(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"])
Cor.Tmp <- cor.test(x = DK.Biodiv[,Var],
y = DK.Biodiv[,"Log.S.AllGrp"])
cor.Tmp$statistic
cor.Tmp$statistic
names(cor.Tmp)
str(cor.Tmp)
Cor.Tmp$statistic
names(Cor.Tmp)
Cor.Tmp$parameter
parameter
Cor.Tmp
str(Cor.Tmp)
paste0(round(Cor.Tmp$estimate,3),"; p = ", round(Cor.Tmp$p.value,3))
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
# Scatter plot of Log.S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19) # make the points filled circles
# To  add a trend line you first need a regression object created with the line() function.
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
# Add a trend line using the abline() function on the lm function created above
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Estimate the correlation between Log.S.AllGrp and the predictor.
Cor.Tmp <- cor.test(x = DK.Biodiv[,Var],
y = DK.Biodiv[,"Log.S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
}
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
# Scatter plot of Log.S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var) # Add a title to the figure
# To  add a trend line you first need a regression object created with the line() function.
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
# Add a trend line using the abline() function on the lm function created above
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Estimate the correlation between Log.S.AllGrp and the predictor.
Cor.Tmp <- cor.test(x = DK.Biodiv[,Var],
y = DK.Biodiv[,"Log.S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
par(mar=rep(4,4))
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
# Scatter plot of Log.S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var) # Add a title to the figure
# To  add a trend line you first need a regression object created with the line() function.
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
# Add a trend line using the abline() function on the lm function created above
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Estimate the correlation between Log.S.AllGrp and the predictor.
Cor.Tmp <- cor.test(x = DK.Biodiv[,Var],
y = DK.Biodiv[,"Log.S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
}
par(mar=rep(4,4))
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
# Scatter plot of Log.S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var) # Add a title to the figure
# To  add a trend line you first need a regression object created with the line() function.
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
# Add a trend line using the abline() function on the lm function created above
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Estimate the correlation between Log.S.AllGrp and the predictor.
Cor.Tmp <- cor.test(x = DK.Biodiv[,Var],
y = DK.Biodiv[,"Log.S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
}
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
# Scatter plot of Log.S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Log Psecies Richness", # Y-axis name
xlab = Var # X-axis name
)
# To  add a trend line you first need a regression object created with the line() function.
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
# Add a trend line using the abline() function on the lm function created above
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Estimate the correlation between Log.S.AllGrp and the predictor.
Cor.Tmp <- cor.test(x = DK.Biodiv[,Var],
y = DK.Biodiv[,"Log.S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
}
Var<-'Dis2Cost'
plot(x = log10(DK.Biodiv[,Var]), # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Log Psecies Richness", # Y-axis name
xlab = Var # X-axis name
)
Reg.Tmp <- line(x = log10(DK.Biodiv[,Var]), # The values for the predictor
y = DK.Biodiv[,"Log.S.AllGrp"]) # The values for the response, )
#
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
Cor.Tmp <- cor.test(x = log10(DK.Biodiv[,Var]),
y = DK.Biodiv[,"Log.S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
formula(paste0("Log.S.AllGrp~"Var))
formula(paste0("Log.S.AllGrp~",Var))
lm(formula(paste0("Log.S.AllGrp~",Var)))
lm(formula(paste0("Log.S.AllGrp~",Var)),
data=DK.Biodiv)
summary(lm(formula(paste0("Log.S.AllGrp~",Var)),
data=DK.Biodiv))
DK.Biodiv <-  read.csv("data/Biowide_AllSppRich.csv")
# Use the function head to print the five forst rows
head(DK.Biodiv)
or (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("NatDensBasMp", "Dis2Cost", "HII", "Slope30mAgg", "PrecSea")){
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
# To  add a trend line you first need a regression object created with the line() function.
Reg.Tmp <- line(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"]) # The values for the response, )
# Add a trend line using the abline() function on the lm function created above
abline(Reg.Tmp, ## the line object to plot
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Estimate the correlation between S.AllGrp and the predictor.
Cor.Tmp <- cor.test(x = log10(DK.Biodiv[,Var]),
y = DK.Biodiv[,"S.AllGrp"])
legend("topright",
legend = paste0("r = ",
round(Cor.Tmp$estimate,3),
"; p = ",
round(Cor.Tmp$p.value,3)))
summary(lm(formula(paste0("S.AllGrp~",Var)),
data=DK.Biodiv))
}
names(DK.Biodiv)
DK.Biodiv.glm <- glm(S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "poisson")
DK.Biodiv.glm
summary(DK.Biodiv.glm)
Summ.DK.Biodiv.glm <- summary(DK.Biodiv.glm)
Summ.DK.Biodiv.glm
# Now extract the coefficients from Summ.DK.Biodiv.glm with the coef() function. save this as an object named Coef.DK.Biodiv.glm
Coef.Summ.DK.Biodiv.glm <- coef(Summ.DK.Biodiv.glm)
# print Coef.Summ.DK.Biodiv.glm, but round all numbers to 3 decimal points
round(x = Coef.Summ.DK.Biodiv.glm, # What to round?
digits = 3) #number of decimal points
# use the summary() function on an object created using the glm() function to get the overview of the regression coefficients.
# save this as an object named  Summ.DK.Biodiv.glm
Summ.DK.Biodiv.glm <- summary(DK.Biodiv.glm)
# print Summ.DK.Biodiv.glm
Summ.DK.Biodiv.glm
?glm
summary(glm(S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "quasipoisson"))
plot(DK.Biodiv.glm)
```{r glmModQuasi}
DK.Biodiv.glmQuasi <- glm(S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "quasipoisson") # Argument defining the adequate error `family`
DK.Biodiv.glmQuasi
DK.Biodiv.glmQuasi <- glm(S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "quasipoisson") # Argument defining the adequate error `family` given the type of the response variable (quasi)binomial for presence/absence and proportion data, and (quasi)Poisson for counts.
# Call the DK.Biodiv.glmQuasi object
DK.Biodiv.glmQuasi
summary(DK.Biodiv.glmQuasi)
summary(DK.Biodiv.glm
)
2455.1  on 114
DK.Biodiv.glmnb <- MASS::glm.nb(S.AllGrp ~ NatDensBasMp + Dis2Cost + HII + Slope30mAgg + PrecSea, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv # specify the Object where the data is in
)
# Call the summary() of the DK.Biodiv.glmnb object
summary(DK.Biodiv.glmnb)
??dispersiontest
plot(DK.Biodiv.glmnb)
par(mfrow=c(2,2))
plot(DK.Biodiv.glmnb)
par(mfrow=c(2,2))
# Plot the object that contains the he regression that addressed the over dispersion problem
plot(DK.Biodiv.glmnb)
class(DK.Biodiv.glmnb)
?plot.negbin
?plot.glm
??plot.glm
??glm.plot
Const.glm <- MASS::glm.nb(S.AllGrp ~ 1, #  the Equations of a Constant model
data = DK.Biodiv # specify the Object where the data is in
)
anova(DK.Biodiv.glmnb, # The FULL Model
Const.glm, # the Constant Model
test = "Chisq") # What test to use
summary(DK.Biodiv.glmnb)
DK.Biodiv.glmnb.Back <- step(DK.Biodiv.glmnb,
direction = "backward")
DK.Biodiv.glmnb.Back
DK.Biodiv.glmnb.Frwd <- step(DK.Biodiv.glmnb,
direction = "forward")
# Call bolger.glm.Back
DK.Biodiv.glmnb.Frwd
DK.Biodiv.glmnb
anova(DK.Biodiv.glmnb.Frwd,DK.Biodiv.glmnb.Back, test = "Chi")
DK.Biodiv.glmnb.Back
131.4/121.6
Const.glm.nb <- MASS::glm.nb(S.AllGrp ~ 1, #  the Equations of a Constant model
data = DK.Biodiv # specify the Object where the data is in
)
anova(DK.Biodiv.glmnb.Back, # The FULL Model
Const.glm.nb, # the Constant Model
test = "Chisq") # What test to use
plot(DK.Biodiv.glmnb.Back)
plot(DK.Biodiv.glmnb.Back)
par(mfrow=c(2,2))
# Plot the object that contains the he regression that addressed the over dispersion problem
plot(DK.Biodiv.glmnb.Back)
names(DK.Biodiv)
DK.Biodiv.glmnb <- MASS::glm.nb(S.AllGrp ~ NatDensBasMp:landsdele + Dis2Cost:landsdele + HII:landsdele + Slope30mAgg:landsdele + PrecSea:landsdele, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv # specify the Object where the data is in
)
summary(DK.Biodiv.glmnb)
# Call the summary() of the DK.Biodiv.glmnb object
summary(step(DK.Biodiv.glmnb))
names(DK.Biodiv)
DK.Biodiv.glmnb <- MASS::glm.nb(S.AllGrp ~ NatDensBasMp:Geology + Dis2Cost:Geology + HII:Geology + Slope30mAgg:Geology + PrecSea:Geology, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv # specify the Object where the data is in
)
# Call the summary() of the DK.Biodiv.glmnb object
summary(step(DK.Biodiv.glmnb))
anova(DK.Biodiv.glmnb, # The FULL Model
Const.glm.nb, # the Constant Model
test = "Chisq")
