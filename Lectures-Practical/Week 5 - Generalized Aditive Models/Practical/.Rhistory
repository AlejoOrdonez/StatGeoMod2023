par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea")){
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
# Build a linear regression object created with the glm() function.
Reg.Tmp <- glm(formula(paste0("S.AllGrp ~",Var)),
data = DK.Biodiv,
family = "poisson")
# Add a trend line using the predict() function on the glm model created above
lines(x=sort(DK.Biodiv[,Var]), # the ordered predictor
y=predict(Reg.Tmp,type="response")[order(DK.Biodiv[,Var])], # the predictions ordered by the predictor
col="red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Build a generalized additive model regression object created with the gam() function.
GAM.Tmp <- gam(formula(paste0("S.AllGrp ~ s(",Var,",k=10)")),
data = DK.Biodiv,
family = "poisson")
# Add a trend line using the predict() function on the gam model created above
lines(x=sort(DK.Biodiv[,Var]),
y=predict(GAM.Tmp,type="response")[order(DK.Biodiv[,Var])],
col="blue",
lwd = 2,  # the width of the line
lty = 2) # the type of the line
}
# Start by setting a plotting space with three (3) rows and two (2) columns, making sure that plots are added row-wise
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea")){
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
# Build a linear regression object created with the glm() function.
Reg.Tmp <- glm(formula(paste0("S.AllGrp ~",Var)),
data = DK.Biodiv,
family = "poisson")
# Add a trend line using the predict() function on the glm model created above
lines(x=sort(DK.Biodiv[,Var]), # the ordered predictor
y=predict(Reg.Tmp,type="response")[order(DK.Biodiv[,Var])], # the predictions ordered by the predictor
col="red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Build a generalized additive model regression object created with the gam() function.
GAM.Tmp <- gam(formula(paste0("S.AllGrp ~ s(",Var,",k=10)")),
data = DK.Biodiv,
family = "poisson")
# Add a trend line using the predict() function on the gam model created above
lines(x=sort(DK.Biodiv[,Var]),
y=predict(GAM.Tmp,type="response")[order(DK.Biodiv[,Var])],
col="blue",
lwd = 2,  # the width of the line
lty = 2) # the type of the line
}
library(mgcv)
library(MASS)
library(raster)
library(car)
# Start by setting a plotting space with three (3) rows and two (2) columns, making sure that plots are added row-wise
par(mfrow = c(3, 2)) # add a vector with the number of rows and number of columns in the plotting space
# start a for() Loop
for (Var in c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea")){
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
# Build a linear regression object created with the glm() function.
Reg.Tmp <- glm(formula(paste0("S.AllGrp ~",Var)),
data = DK.Biodiv,
family = "poisson")
# Add a trend line using the predict() function on the glm model created above
lines(x=sort(DK.Biodiv[,Var]), # the ordered predictor
y=predict(Reg.Tmp,type="response")[order(DK.Biodiv[,Var])], # the predictions ordered by the predictor
col="red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
# Build a generalized additive model regression object created with the gam() function.
GAM.Tmp <- gam(formula(paste0("S.AllGrp ~ s(",Var,",k=10)")),
data = DK.Biodiv,
family = "poisson")
# Add a trend line using the predict() function on the gam model created above
lines(x=sort(DK.Biodiv[,Var]),
y=predict(GAM.Tmp,type="response")[order(DK.Biodiv[,Var])],
col="blue",
lwd = 2,  # the width of the line
lty = 2) # the type of the line
}
# table comparing the deviance explained by by each predictor based on your GLM and GAM
# Save the table as an object named DevTable
DevTable <- sapply(c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea"),
function(Var){
# Build a linear regression object created with the glm() function.
GLMM.Tmp <- glm(formula(paste0("S.AllGrp ~",Var)),
data = DK.Biodiv,
family = "poisson")
# Build a generalized additive model regression object created with the gam() function.
GAM.Tmp <- gam(formula(paste0("S.AllGrp ~ s(",Var,",k=10)")),
data = DK.Biodiv,
family = "poisson")
# Build a GLM model with (NO PREDICTORS) - the null model
Null.mod <- glm("S.AllGrp ~1",
data = DK.Biodiv,
family = "poisson")
# Extract the deviances explained per model
GLMM.Dev.Tmp <- deviance(GLMM.Tmp)
GAM.Dev.Tmp <- deviance(GAM.Tmp)
Null.Dev.Tmp <- deviance(Null.mod)
# Estimate deviance  explained per model
GLMM.Dev.Exp <- (Null.Dev.Tmp - GLMM.Dev.Tmp)/Null.Dev.Tmp
GAM.Dev.Exp <- (Null.Dev.Tmp - GAM.Dev.Tmp)/Null.Dev.Tmp
# Generate a table with the outputs
data.frame(Predictor = Var,
GLMM.Dev.Exp,
GAM.Dev.Exp)
})
# Call DevTable
DevTable
DK.Biodiv.glm <- glm(S.AllGrp ~ logitNatDensBasMp + log10Dis2Cost + HII + log10Slope30mAgg + PrecSea, #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "poisson") # Argument defining the adequate error `family` given the type of the response variable (quasi)binomial for presence/absence and proportion data, and (quasi)Poisson for counts.
# Print the summary of the glm model
summary(DK.Biodiv.glm)
1-(2454.3/2704.0)
DK.Biodiv.gam <- gam(S.AllGrp ~ s(logitNatDensBasMp, k=10) + s(log10Dis2Cost, k=10) + s(HII, k=10) + s(log10Slope30mAgg, k=10) + s(PrecSea, k=10), #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "poisson", # Argument defining the adequate error `family` given the type of the response variable (quasi)binomial for presence/absence and proportion data, and (quasi)Poisson for counts.
method ="REML")
# Print the summary of the gam model
summary(DK.Biodiv.gam)
DK.Biodiv.gam.2 <- gam(S.AllGrp ~ s(logitNatDensBasMp,k=10) + s(log10Dis2Cost,k=10) + s(HII,k=10) + s(log10Slope30mAgg,k=10) + s(PrecSea,k=10) + s(decimalLongitude,decimalLatitude, bs="tp"), #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "poisson", # Argument defining the adequate error `family` given the type of the response variable (quasi)binomial for presence/absence and proportion data, and (quasi)Poisson for counts.
method ="REML")
# Print the summary of the gam model
summary(DK.Biodiv.gam.2)
par(mfcol= c(2,2))
gam.check(DK.Biodiv.gam.2, # a fitted gam
type = "deviance", # type of residuals
rep = 500)
DK.Biodiv.gam.3 <- update(DK.Biodiv.gam.2, # the model to update
select = TRUE ) #add an extra penalty to each term so that it can be penalized to zero
# Print the summary of the DK.Biodiv.gam.3 object
summary(DK.Biodiv.gam.3)
UpdateMod <- lapply(strsplit(as.character(formula(DK.Biodiv.gam.3))[[3]]," [+] ")[[1]],
function(x){
update(DK.Biodiv.gam.3, # the model to update
formula(paste('. ~ . - ',x)))# Updated formula
})
DevChng <- sapply(UpdateMod,
function(x){
out <- anova(x, # Reduced model
DK.Biodiv.gam.3, # Full Model
test="Chisq" # type of test
)
c(Deviance = out$Deviance[2],
Pval = out[2,'Pr(>Chi)'])
})
# Contrast the AIC of the full and reduced models stored in UpdateMod
AIC.Dif <- sapply(UpdateMod,
function(x){
AIC(x, # Reduced model
DK.Biodiv.gam.3)$AIC # Full Model)
})
# create  data.frame to summarize the deviance tests
data.frame (VarRem = strsplit(as.character(formula(DK.Biodiv.gam.3))[[3]]," [+] ")[[1]],
t(round(DevChng, 3)),
AIC.Reduced = AIC.Dif[1,],
AIC.full = AIC.Dif[2,])
# Plot the best model
plot(DK.Biodiv.gam.3,
pages = 1, # the number of pages over which to spread the output
scheme = 2, # produces a heat-map, with overlaid contours and
shade = TRUE) # produce shaded regions as confidence bands
NatDensBasMpRst <- raster("Data/NatDensBasMp.tif")
# Load the Dis2Cost raster
Dis2CostRst <- raster("Data/Dis2Cost.tif")
# Load the HII raster
HIIRst <- raster("Data/HII.tif")
# Load the Slope30mAgg raster
Slope30mAggRst <- raster("Data/Slope30mAgg.tif")
# Load the PrecSea raster
PrecSeaRst <- raster("Data/PrecSea.tif")
HIIRst <- projectRaster(from = HIIRst,
to = NatDensBasMpRst)
Slope30mAggRst <- projectRaster(from = Slope30mAggRst,
to = NatDensBasMpRst)
# Stack the corrected rasters
Pred.Rast <- stack(NatDensBasMpRst, # Nature Density Raster
Dis2CostRst, # Distance to coast Raster
HIIRst, # HII to coast
Slope30mAggRst, # Slope to coast
PrecSeaRst # Precipitation seasonality to coast
)
# call the Pred.Rast object
Pred.Rast
LatRast <- raster(Pred.Rast)
## re-project the created raster
LatRast <- projectRaster(from = LatRast, # Transformation
crs = CRS("+proj=longlat +datum=WGS84 +no_defs") # CRS object
)
## Add the values to the created raster
LatRast[] <- coordinates(LatRast)[,"y"]
## re-project created raster
LatRast <- projectRaster(from = LatRast,
to = Pred.Rast)
## Append new rasters to Pred.Rast
Pred.Rast <- stack(Pred.Rast,
LatRast) # new Raster 1
# Create a empt raster with the same attributes as Pred.Rast using the function raster
LongRast <- raster(Pred.Rast)
## re-project the created raster
LongRast <- projectRaster(from = LongRast, # Transformation
crs = CRS("+proj=longlat +datum=WGS84 +no_defs") # CRS object
)
## Add the values to the created raster
LongRast[] <- coordinates(LongRast)[,"y"]
## re-project created raster
LongRast <- projectRaster(from = LongRast,
to = Pred.Rast)
## Append new rasters to Pred.Rast
Pred.Rast <- stack(Pred.Rast,
LongRast) # new Raster 1
# call the Pred.Rast object
Pred.Rast
logitNatDensBasMpRst <- calc(NatDensBasMpRst,
function(x){
ifelse(!is.na(x),
car::logit(x),
NA)
})
## Add logitNatDensBasMpRst to Pred.Rast
Pred.Rast <- stack(Pred.Rast,
logitNatDensBasMpRst)
## Transform Dis2CostRst
log10Dis2CostRst <- log10(Dis2CostRst)
## Add log10Dis2CostRst to Pred.Rast
Pred.Rast <- stack(Pred.Rast,
log10Dis2CostRst)
## Transform Slope30mAggRst
log10Slope30mAggRst <- log10(Slope30mAggRst)
## Add log10Slope30mAggRst to Pred.Rast
Pred.Rast <- stack(Pred.Rast,
log10Slope30mAggRst = log10Slope30mAggRst)
# call the Pred.Rast object
Pred.Rast
DK.Biodiv <-  read.csv("Data/Biowide_AllSppRich.csv")
DK.Biodiv$HII
plot(x=DK.Biodiv$HII,)
y = DK.Biodiv$S.AllGrp,)
plot(x=DK.Biodiv$HII,y = DK.Biodiv$S.AllGrp)
plot(x=DK.Biodiv$HII,y = DK.Biodiv$S.AllGrp,type="l")
plot(x=DK.Biodiv$HII[order(DK.Biodiv$HII)],y = DK.Biodiv$S.AllGrp[order(DK.Biodiv$HII)],type="l")
?predict.glm
?predict.gam
\
require(mgcv)
?predict.gam
(Var<-"HII")
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
paste("S.AllGrp ~ ",Var)
formula(paste("S.AllGrp ~ ",Var))
Reg.Tmp <- glm(formula(paste("S.AllGrp ~ ",Var)), # the model formula
data = DK.Biodiv, # Data
family = "poisson") # Family of the Response
Reg.Tmp
DK.Biodiv[,Var]
predict(Reg.Tmp)
hist(predict(Reg.Tmp))
predict(Reg.Tmp,
type = "response")
hist(predict(Reg.Tmp,
type = "response"))
order(DK.Biodiv[,Var])
sort(DK.Biodiv[,Var])
(Var<-"HII")
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
# Build a linear regression object created with the glm() function.
# use the functions formula and paste to define the model
Reg.Tmp <- glm(formula(paste("S.AllGrp ~ ",Var)), # the model formula
data = DK.Biodiv, # Data
family = "poisson") # Family of the Response
# Add a trend line using the function lines()
# use the function predict()  on the glm model created above to get the expected values
lines(x = sort(DK.Biodiv[,Var]), # the ordered predictor
y = predict(Reg.Tmp,
type = "response")[order(DK.Biodiv[,Var])],# the predictions ordered by the predictor
col = "red", # the colour of the line
lwd = 2,  # the width of the line
lty = 2) # the type of the line
paste("S.AllGrp ~ s(",Var,")")
GAM.Tmp <- gam(formula(paste("S.AllGrp ~ s(",Var,")")), # the model formula
data = DK.Biodiv, # Data
family = "poisson", # Family of the Response
method ="REML") # The smoothing parameter estimation
GAM.Tmp
predict(GAM.Tmp,
type = "response")[order(DK.Biodiv[,Var])]
lines(x = sort(DK.Biodiv[,Var]), # the ordered predictor
y = predict(GAM.Tmp,
type = "response")[order(DK.Biodiv[,Var])],# the predictions ordered by the predictor
col="blue",
lwd = 2,  # the width of the line
lty = 2) #
DK.Biodiv.tmp <- DK.Biodiv[,c("S.AllGrp",Var)]
names(DK.Biodiv.tmp)
names(DK.Biodiv.tmp) <- c("S.AllGrp","Var")
names(DK.Biodiv.tmp)
rm(list=ls());gc()
rm(list=ls());gc()
DK.Biodiv <-  read.csv("Data/Biowide_AllSppRich.csv")
# Use the function head to print the five first rows
head(DK.Biodiv)
DK.Biodiv <- DK.Biodiv[DK.Biodiv$log10Slope30mAgg>0,]
DK.Biod\
DK.Biodiv$HII
plot(DK.Biodiv$HII,DK.Biodiv$S.AllGrp)
plot(DK.Biodiv$HII,DK.Biodiv$S.AllGrp,type="l")
sort(DK.Biodiv$HII)
order(DK.Biodiv$HII)
plot(sort(DK.Biodiv$HII),DK.Biodiv$S.AllGrp,type="l")
plot(sort(DK.Biodiv$HII),DK.Biodiv$S.AllGrp[order(DK.Biodiv$HII)],type="l")
(Var<-"HII")
# Scatter plot of S.AllGrp vs the evaluated predictor using the test.
plot(x = DK.Biodiv[,Var], # The values for the predictor
y = DK.Biodiv[,"S.AllGrp"], # The values for the response,
pch = 19, # make the points filled circles
main = Var,  # Add a title to the figure
ylab = "Species Richness", # Y-axis name
xlab = Var # X-axis name
)
paste("S.AllGrp ~",Var)
formula(paste("S.AllGrp ~",Var))
formula(paste("S.AllGrp ~",Var))
glm(S.AllGrp ~ Var
#formula(paste("S.AllGrp ~",Var)) , # the model formula
data = DK.Biodiv, # Data
glm(S.AllGrp ~ Var,
#formula(paste("S.AllGrp ~",Var)) , # the model formula
data = DK.Biodiv, # Data
family = "poisson")
paste("S.AllGrp ~",Var)
paste("S.AllGrp ~",Var,sep=".")
paste0("S.AllGrp ~",Var)
Reg.Tmp <- glm(S.AllGrp ~ DK.Biodiv[,Var], # the model formula
data = DK.Biodiv, # Data
family = "poisson") # Family of the Response
Var
DK.Biodiv[,Var]
Reg.Tmp <- glm(DK.Biodiv[,"S.AllGrp"] ~ DK.Biodiv[,Var], # the model formula
#data = DK.Biodiv, # Data
family = "poisson") # Family of the Response
DK.Biodiv.gam.2 <- gam(S.AllGrp ~ s(logitNatDensBasMp,k=10) + s(log10Dis2Cost,k=10) + s(HII,k=10) + s(log10Slope30mAgg,k=10) + s(PrecSea,k=10) + s(decimalLongitude,decimalLatitude, bs="tp"), #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv, # specify the Object where the data is in
family = "poisson", # Argument defining the adequate error `family` given the type of the response variable (quasi)binomial for presence/absence and proportion data, and (quasi)Poisson for counts.
method ="REML")
DK.Biodiv.gam.3 <- update(DK.Biodiv.gam.2, # the model to update
method = "ML" )
DK.Biodiv.gam.3
summary(DK.Biodiv.gam.3)
summary(DK.Biodiv.gam.2)
DK.Biodiv.glm
ls()
UpdateMod <- update(DK.Biodiv.gam.3,
. ~ . -s(HII))
UpdateMod
UpdateMod <- update(DK.Biodiv.gam.3,
. ~ . -s(HII, k =10))
UpdateMod <- update(DK.Biodiv.gam.3,
. ~ . -s(HII, k =10)
UpdateMod
UpdateMod <- update(DK.Biodiv.gam.3,
. ~ . -s(HII, k =10))
UpdateMod
DevChng <- anova(DK.Biodiv.gam.3,
UpdateMod,
test = "Chisq")
DevChng
AIC.Dif <- AIC(DK.Biodiv.gam.3,
UpdateMod)
AIC.Dif
DevChng$Deviance
data.frame (VarRem = "HII",
Deviance = DevChng$Deviance[2],
P.Val = DevChng$`Pr(>Chi)`[2],
AIC.Reduced = AIC.Dif$AIC[2],
AIC.full = AIC.Dif$AIC[1])
anova(UpdateMod,
DK.Biodiv.gam.3,
test = "Chisq")
# Update the full model to a simpler models - with one variable removed -  use the function update() to remove variables from the full model.
sapply(c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea"),
function(Var){
UpdateMod <- update(DK.Biodiv.gam.3,
formula(paste(". ~ . -s(",Var", k =10)")))
# Update the full model to a simpler models - with one variable removed -  use the function update() to remove variables from the full model.
sapply(c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea"),
function(Var){
UpdateMod <- update(DK.Biodiv.gam.3,
formula(paste(". ~ . -s(",Var,"k =10)")))
# Evaluate the change in deviance of simpler models - with one variable removed - use the function anova() to contrast the full gam to those with one less variable now stored in UpdateMod
DevChng <- anova(UpdateMod,
DK.Biodiv.gam.3,
test = "Chisq")
# Contrast the AIC of the full and reduced models stored in UpdateMod
AIC.Dif <- AIC(DK.Biodiv.gam.3,
UpdateMod)
# create  data.frame to summarize the tests
data.frame (VarRem = Var,
Deviance = DevChng$Deviance[2],
P.Val = DevChng$`Pr(>Chi)`[2],
AIC.Reduced = AIC.Dif$AIC[2],
AIC.full = AIC.Dif$AIC[1])
})
Var
formula(paste(". ~ . -s(",Var,"k =10)"))
paste(". ~ . -s(",Var,"k =10)")
# Update the full model to a simpler models - with one variable removed -  use the function update() to remove variables from the full model.
sapply(c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea"),
function(Var){
UpdateMod <- update(DK.Biodiv.gam.3,
formula(paste(". ~ . -s(",Var,", k =10)")))
# Evaluate the change in deviance of simpler models - with one variable removed - use the function anova() to contrast the full gam to those with one less variable now stored in UpdateMod
DevChng <- anova(UpdateMod,
DK.Biodiv.gam.3,
test = "Chisq")
# Contrast the AIC of the full and reduced models stored in UpdateMod
AIC.Dif <- AIC(DK.Biodiv.gam.3,
UpdateMod)
# create  data.frame to summarize the tests
data.frame (VarRem = Var,
Deviance = DevChng$Deviance[2],
P.Val = DevChng$`Pr(>Chi)`[2],
AIC.Reduced = AIC.Dif$AIC[2],
AIC.full = AIC.Dif$AIC[1])
})
# Update the full model to a simpler models - with one variable removed -  use the function update() to remove variables from the full model.
ModRed <- sapply(c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea"),
function(Var){
UpdateMod <- update(DK.Biodiv.gam.3,
formula(paste(". ~ . -s(",Var,", k =10)")))
# Evaluate the change in deviance of simpler models - with one variable removed - use the function anova() to contrast the full gam to those with one less variable now stored in UpdateMod
DevChng <- anova(UpdateMod,
DK.Biodiv.gam.3,
test = "Chisq")
# Contrast the AIC of the full and reduced models stored in UpdateMod
AIC.Dif <- AIC(DK.Biodiv.gam.3,
UpdateMod)
# create  data.frame to summarize the tests
data.frame (VarRem = Var,
Deviance = DevChng$Deviance[2],
P.Val = DevChng$`Pr(>Chi)`[2],
AIC.Reduced = AIC.Dif$AIC[2],
AIC.full = AIC.Dif$AIC[1])
})
t(ModRed )
ModRed
for(  Var in c("logitNatDensBasMp", "log10Dis2Cost", "HII", "log10Slope30mAgg", "PrecSea")){
UpdateMod <- update(DK.Biodiv.gam.3,
formula(paste(". ~ . -s(",Var,", k =10)")))
# Evaluate the change in deviance of simpler models - with one variable removed - use the function anova() to contrast the full gam to those with one less variable now stored in UpdateMod
DevChng <- anova(UpdateMod,
DK.Biodiv.gam.3,
test = "Chisq")
# Contrast the AIC of the full and reduced models stored in UpdateMod
AIC.Dif <- AIC(DK.Biodiv.gam.3,
UpdateMod)
# create  data.frame to summarize the tests
TEmp <-data.frame (VarRem = Var,
Deviance = DevChng$Deviance[2],
P.Val = DevChng$`Pr(>Chi)`[2],
AIC.Reduced = AIC.Dif$AIC[2],
AIC.full = AIC.Dif$AIC[1])
if(Var == "logitNatDensBasMp")
out <- TEmp
else
out <- rbind(out,TEmp)
}
out
par(mfrow=c(round(length(names(coef(DK.Biodiv.lm))[-1])/2),2))
DK.Biodiv.lm <- lm(Log.S.AllGrp ~ ., #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv[,-c(1:4)]) # dataset (removing the variables not of interest)
# Read the file and save it as an object named `DK.Biodiv`
DK.Biodiv <-  read.csv("data/Biowide_AllSppRichV2.csv")
