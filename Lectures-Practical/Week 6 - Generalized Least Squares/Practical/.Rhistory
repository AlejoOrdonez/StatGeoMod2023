require(nlme)
require(sp)
require(ape)
DK.Biodiv.Spatial <- DK.Biodiv
# Extract the standardized residuals of the `DK.Biodiv.lm` object
DK.Biodiv.Spatial$Resid <- rstandard(DK.Biodiv.lm)
# Transform the `DK.Biodiv.Spatial` to a `SpatialPointsDataframe`
coordinates(DK.Biodiv.Spatial) <- ~decimalLongitude+decimalLatitude
# Define the right reference system to `DK.Biodiv.Spatial`.
proj4string(DK.Biodiv.Spatial) <- CRS("+proj=longlat")
DK.Biodiv.Spatial <- spTransform(DK.Biodiv.Spatial,CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs"))
DK.Biodiv.Spatial <- DK.Biodiv
# Extract the standardized residuals of the `DK.Biodiv.lm` object
DK.Biodiv.Spatial$Resid <- rstandard(DK.Biodiv.lm)
# Transform the `DK.Biodiv.Spatial` to a `SpatialPointsDataframe`
coordinates(DK.Biodiv.Spatial) <- ~decimalLongitude+decimalLatitude
# Define the right reference system to `DK.Biodiv.Spatial`.
proj4string(DK.Biodiv.Spatial) <- CRS("+proj=longlat")
# Re-project `DK.Biodiv.Spatial` to `UTM/ETRS89`.
DK.Biodiv.Spatial <- spTransform(DK.Biodiv.Spatial,CRS("+proj=utm +zone=32"))
DK.Biodiv.Spatial
DK.Biodiv.Spatial$X <- coordinates(DK.Biodiv.Spatial)[,'decimalLongitude']
DK.Biodiv.Spatial$Y <- coordinates(DK.Biodiv.Spatial)[,'decimalLatitude']
plot(DK.Biodiv.Spatial,
pch=19)
require(raster)
?getData
getData('GADM', country='DK', level=0, path="data/")
DK.Map <- readRSD("data/gadm36_DNK_0_sp.rds")
DK.Map <- readRDS("data/gadm36_DNK_0_sp.rds")
plot(DK.Biodiv.Spatial,
pch=19)
plot(DK.Map)
DK.Map
DK.Map <- spTransform(DK.Map,CRS("+proj=utm +zone=32"))
DK.Map <- readRDS("data/gadm36_DNK_0_sp.rds")
projection(DK.Map)
DK.Map <- spTransform(DK.Map,CRS("+proj=utm +zone=32"))
projection(DK.Biodiv.Spatial)
DK.Biodiv.Spatial <- DK.Biodiv
# Extract the standardized residuals of the `DK.Biodiv.lm` object
DK.Biodiv.Spatial$Resid <- rstandard(DK.Biodiv.lm)
# Transform the `DK.Biodiv.Spatial` to a `SpatialPointsDataframe`
coordinates(DK.Biodiv.Spatial) <- ~decimalLongitude+decimalLatitude
# Define the right reference system to `DK.Biodiv.Spatial`.
proj4string(DK.Biodiv.Spatial) <- CRS("+proj=longlat")
# Re-project `DK.Biodiv.Spatial` to `UTM/ETRS89`.
DK.Biodiv.Spatial <- spTransform(DK.Biodiv.Spatial,CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs"))
plot(DK.Biodiv.Spatial,
pch=19)
# Load a map of Denmark
DK.Map <- readRDS("data/gadm36_DNK_0_sp.rds")
DK.Map <- spTransform(DK.Map,CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs"))
DK.Map <- readRDS("data/gadm36_DNK_0_sp.rds")
DK.Map <- readRDS("data/gadm36_DNK_0_sp.rds")
DK.Map
DK.Map <- spTransform(DK.Map,
CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs"))
?spTransform
DK.Map <- spTransform(DK.Map,
CRSobj = CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs"))
plot(DK.Map)
DK.Biodiv.Spatial$Resid <- rstandard(DK.Biodiv.lm)
#spatial representation of the normalized residual variation.
bubble(obj = DK.Biodiv.Spatial, # the Spatial object to plot
zcol = "Resid") # column name, or column number of the variable to plot
?bubble
bubble(obj = DK.Biodiv.Spatial, # the Spatial object to plot
zcol = "Resid") + sp.lines(DK.Map)#
bubble(obj = DK.Biodiv.Spatial, # the Spatial object to plot
zcol = "Resid") + polygon(DK.Map)# column name, or column number of the
?xyplot
?bubble
bubble(obj = DK.Biodiv.Spatial, # the Spatial object to plot
zcol = "Resid")
polygon(DK.Map,add=T)# column name, or column number of the variable to plot
bubble(obj = DK.Biodiv.Spatial, # the Spatial object to plot
zcol = "Resid") + polygon(DK.Map,add=T)# column name, or column number of
DK.Biodiv.gls <- gls(formula(DK.Biodiv.lm),
data = DK.Biodiv.Spatial,
method ="REML")
# call the summary of DK.Biodiv.gls
summary(DK.Biodiv.gls)
DK.Biodiv.gls.Vargrm <- Variogram(DK.Biodiv.gls,
form = ~ X + Y,
resType = "normalized")
DK.Biodiv.Spatial$X <- coordinates(DK.Biodiv.Spatial)[,'decimalLongitude']
DK.Biodiv.Spatial$Y <- coordinates(DK.Biodiv.Spatial)[,'decimalLatitude']
DK.Biodiv.gls.Vargrm <- Variogram(DK.Biodiv.gls,
form = ~ X + Y,
resType = "normalized")
plot(DK.Biodiv.gls.Vargrm)
DistDKBio <- dist(coordinates(DK.Biodiv.Spatial))
#Extract the `normalized` residuals
NorResGls <- residuals(DK.Biodiv.gls, # Model
type = "normalized") # the residuals type
# Estimate Moran I of the residuals
Moran.I(NorResGls, # the variable to evaluate
w = as.matrix(DistDKBio) # the Distance matrix
)
DK.Biodiv.glsExp <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corExp(form = ~X + Y, nugget = TRUE),
method = "REML")
# Fit a Gaussian correlation model
DK.Biodiv.glsGaus <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corGaus(form = ~X + Y, nugget = TRUE),
method = "REML")
# Fit a Linear correlation model
DK.Biodiv.glsLin <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corLin(form = ~X + Y, nugget = TRUE),
method = "REML")
DK.Biodiv.glsExp <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corExp(form = ~X + Y, nugget = TRUE),
method = "REML")
# Fit a Gaussian correlation model
DK.Biodiv.glsGaus <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corGaus(form = ~X + Y, nugget = TRUE),
method = "REML")
# Fit a Linear correlation model
DK.Biodiv.glsLin <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corLin(form = ~X + Y, nugget = TRUE),
method = "REML")
DK.Biodiv.glsExp <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corExp(form = ~X + Y, nugget = TRUE),
method = "REML")
DK.Biodiv.glsGaus <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corGaus(form = ~X + Y, nugget = TRUE),
method = "REML")
DK.Biodiv.glsLin <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corLin(form = ~X + Y, nugget = TRUE),
method = "REML")
DK.Biodiv.glsLin
DK.Biodiv.glsLin <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corLin(form = ~X + Y, nugget = TRUE),
method = "REML",
optimizer = optim)
?gls
DK.Biodiv.glsLin <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corLin(form = ~X + Y, nugget = TRUE),
method = "REML",
glsControl = list(opt = c("optim")))
DK.Biodiv.glsRatio <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corRatio(form = ~X + Y, nugget = TRUE),
method = "REML")
DK.Biodiv.glsSpher <- gls(formula(DK.Biodiv.gls),
data = DK.Biodiv.Spatial,
correlation = corSpher(form = ~X + Y, nugget = TRUE),
method = "REML")
AIC(DK.Biodiv.glsExp,
DK.Biodiv.glsGaus,
DK.Biodiv.glsRatio,
DK.Biodiv.glsSpher
)
anova(DK.Biodiv.glsSpher,
DK.Biodiv.gls)
DK.Biodiv.glsSpher.ML <- update(DK.Biodiv.glsSpher,
method="ML")
step(DK.Biodiv.glsSpher.ML)
stepAIC(DK.Biodiv.glsSpher.ML)
MASS::stepAIC(DK.Biodiv.glsSpher.ML)
?setpAIC
??setpAIC
require(MASS)
?setpAIC
??stepAIC
DK.Biodiv.glsSpher.ML.Updated <- MASS::stepAIC(DK.Biodiv.glsSpher.ML,
direction = "both")
summary(DK.Biodiv.glsSpher.ML.Updated)
# updating the inferencer method of the model with a correlation stricture
DK.Biodiv.glsSpher.ML.Updated <- update(DK.Biodiv.glsSpher.ML.Updated,
method="REML")
# Call the summary of the reduced model
summary(DK.Biodiv.glsSpher.ML.Updated)
summary(DK.Biodiv.glsSpher.ML.Updated)
plot(DK.Biodiv.glsSpher.ML.Updated)
# Evaluate graphically the assumptions of your reduced linear model
plot(DK.Biodiv.glsSpher.ML.Updated)
residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized")
qqnorm(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
plot(DK.Biodiv.glsSpher.ML.Updated)
qqnorm(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
qqnorm(residuals(DK.Biodiv.glsSpher.ML.Updated,type="pearson"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="pearson"))
qqnorm(residuals(DK.Biodiv.glsSpher.ML.Updated,type="pearson"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="pearson"))
?plot.gls
plot(DK.Biodiv.glsSpher.ML.Updated,
idResType = "pearson")
fm1 <- gls(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary,
correlation = corAR1(form = ~ 1 | Mare))
# standardized residuals versus fitted values by Mare
plot(fm1, resid(., type = "p") ~ fitted(.) | Mare, abline = 0)
plot(fm1, Mare ~ resid(.))
plot(fm1, follicles ~ fitted(.) | Mare, abline = c(0,1))
plot(DK.Biodiv.glsSpher.ML.Updated,
abline=0,
idResType = "pearson")
qqnorm(residuals(DK.Biodiv.glsSpher.ML.Updated,type="pearson"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="pearson"))
plot(DK.Biodiv.glsSpher.ML.Updated,
abline=0,
idResType = "normalized")
qqnorm(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
qqline(residuals(DK.Biodiv.glsSpher.ML.Updated,type="normalized"))
DK.Biodiv.gls.Vargrm2 <- Variogram(DK.Biodiv.glsSpher.ML.Updated,
form = ~ X + Y,
resType = "normalized")
plot(DK.Biodiv.gls.Vargrm)
plot(DK.Biodiv.gls.Vargrm2)
?rstandard
?spTransform
plot(DK.Biodiv.glsSpher.ML.Updated, # Model
abline=0, # add a horizontal line at Zero
idResType = "normalized" # Residual type
)
lines(lowess(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated),# Predictor
lwd = 2, # Line width
lty = 2, # Dasehd line
col = "red")  # color of the line
plot(DK.Biodiv.glsSpher.ML.Updated, # Model
abline=0, # add a horizontal line at Zero
idResType = "normalized" # Residual type
)
residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized")
redict(DK.Biodiv.glsSpher.ML.Updated)
lines(lowess(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated)),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
plot(DK.Biodiv.glsSpher.ML.Updated, # Model
abline=0, # add a horizontal line at Zero
idResType = "normalized" # Residual type
)
plot(DK.Biodiv.glsSpher.ML.Updated, # Model
abline=0, # add a horizontal line at Zero
idResType = "normalized" # Residual type
)
plot(DK.Biodiv.glsSpher.ML.Updated, # Model
abline=0, # add a horizontal line at Zero
idResType = "normalized" # Residual type
)
axis(1)
lines(lowess(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated)),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
plot(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated),# Predictor
pch=19)
lines(lowess(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated)),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
plot(DK.Biodiv.glsSpher.ML.Updated, # Model
abline=0, # add a horizontal line at Zero
idResType = "normalized" # Residual type
)
ablune(h=0,
col = "red",
lty=3)
plot(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated),# Predictor
pch=19, #point type
ylab = "Standarized residuals", # y-axis Label
xlab = "fitted values" # x-axis Label
)
abline(h=0,
col = "red",
lty=3)
plot(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated),# Predictor
pch=19, #point type
ylab = "Standarized residuals", # y-axis Label
xlab = "fitted values" # x-axis Label
)
abline(h=0,
col = "red",
lty=3,
lwd=2)
lines(lowess(y = residuals(DK.Biodiv.glsSpher.ML.Updated,"normalized"), # Residuals
x = predict(DK.Biodiv.glsSpher.ML.Updated)),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
?Moran.I
require(nlme)
require(sp)
require(ape)
require(MASS)
DK.Biodiv <-  read.csv("data/Biowide_AllSppRichV2.csv")
# Use the function head to print the five first rows
head(DK.Biodiv)
DK.Biodiv.lm <- lm(Log.S.AllGrp ~ ., #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv[,-c(1:4)]) # dataset (removing the variables not of interest)
# Print the summary of DK.Biodiv.lm
summary(DK.Biodiv.lm)
DK.Biodiv.Spatial <- DK.Biodiv # copy the original data
# Extract the standardized residuals of the `DK.Biodiv.lm` object
DK.Biodiv.Spatial$Resid <- rstandard(model = DK.Biodiv.lm) # Model to extract the residuals
# Transform the `DK.Biodiv.Spatial` to a `SpatialPointsDataframe`
coordinates(DK.Biodiv.Spatial) <- ~decimalLongitude+decimalLatitude
# Define the right reference system to `DK.Biodiv.Spatial`.
proj4string(DK.Biodiv.Spatial) <- CRS("+proj=longlat") # The
# Re-project `DK.Biodiv.Spatial` to `UTM/ETRS89`.
DK.Biodiv.Spatial <- spTransform(DK.Biodiv.Spatial, # object to be transformed
CRSobj = CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs")# New Projection
)
# Add the projected X and Y to the Data frame of the Spatial object
DK.Biodiv.Spatial$X <- coordinates(DK.Biodiv.Spatial)[,'decimalLongitude']
DK.Biodiv.Spatial$Y <- coordinates(DK.Biodiv.Spatial)[,'decimalLatitude']
require(maptools)
??worldmap
data(wrld_simpl)
DK.Map <- wrld_simpl[wrld_simpl$NAME=="Denmark"]
DK.Map <- wrld_simpl[wrld_simpl$NAME=="Denmark",]
plot(DK.Map)
DK.Map <- spTransform(DK.Map, # object to be transformed
CRSobj = CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs") # New Projection
)
DK.Biodiv.Spatial$Resid <- rstandard(DK.Biodiv.lm)
#spatial representation of the normalized residual variation.
bubble(obj = DK.Biodiv.Spatial, # the Spatial object to plot
zcol = "Resid",
panel= sp.polygons(DK.Map)
)
bubble(DK.Biodiv.Spatial,
"Resid",
panel=function(...) {
sp.polygons(DK.Map, fill="NA")
sp:::panel.bubble(...)
})
bubble(DK.Biodiv.Spatial,
"Resid",
panel=function(...) {
sp:::panel.bubble(...)
sp.polygons(DK.Map, fill="NA")
})
axis(1)
axis(1,xdp=NA)
par()
require(nlme)
require(sp)
require(ape)
require(MASS)
# Read the file and save it as an object named `DK.Biodiv`
DK.Biodiv <-  read.csv("data/Biowide_AllSppRichV2.csv")
# Use the function head to print the five first rows
head(DK.Biodiv)
DK.Biodiv.lm <- lm(Log.S.AllGrp ~ ., #  the Equations defining the response and additive combination of predictors
data = DK.Biodiv[,-c(1:4)]) # dataset (removing the variables not of interest)
# Print the summary of DK.Biodiv.lm
summary(DK.Biodiv.lm)
par(mfrow=c(round(length(names(coef(DK.Biodiv.lm))[-1])/2),2))
# Loop across the predictors
for(VarUse in names(coef(DK.Biodiv.lm))[-1]){
# Plot the Residuals vs the predictor
plot(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse], # Predictor
ylab = "Log.S.AllGrp", # Labels
xlab = VarUse, # Labels
pch=19)  # Point type
# add a smoother trend line using lowess
lines(lowess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse]),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
}
# Set a piloting space
par(mfrow=c(round(length(names(coef(DK.Biodiv.lm))[-1])/2),2))
# Loop across the predictors
for(VarUse in names(coef(DK.Biodiv.lm))[-1]){
# Plot the Residuals vs the predictor
plot(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse], # Predictor
ylab = "Log.S.AllGrp", # Labels
xlab = VarUse, # Labels
pch=19)  # Point type
# add a smoother trend line using lowess
lines(lowess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse]),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
}
par(mfrow=c(round(length(names(coef(DK.Biodiv.lm))[-1])/2),2))
# Loop across the predictors
for(VarUse in names(coef(DK.Biodiv.lm))[-1]){
# Plot the Residuals vs the predictor
plot(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse], # Predictor
ylab = "Log.S.AllGrp", # Labels
xlab = VarUse, # Labels
pch=19)  # Point type
# add a smoother trend line using lowess
lines(lowess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse]),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
}
plot(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse], # Predictor
ylab = "Log.S.AllGrp", # Labels
xlab = VarUse, # Labels
pch=19)  # Po
# Set a piloting space
par(mfrow=c(round(length(names(coef(DK.Biodiv.lm))[-1])/2),2))
# Loop across the predictors
for(VarUse in names(coef(DK.Biodiv.lm))[-1]){
# Plot the Residuals vs the predictor
plot(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse], # Predictor
ylab = "Log.S.AllGrp", # Labels
xlab = VarUse, # Labels
pch=19)  # Point type
# add a smoother trend line using lowess
lines(lowess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse]),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
}
# Set a piloting space
dev.new()
par(mfrow=c(round(length(names(coef(DK.Biodiv.lm))[-1])/2),2))
# Loop across the predictors
for(VarUse in names(coef(DK.Biodiv.lm))[-1]){
# Plot the Residuals vs the predictor
plot(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse], # Predictor
ylab = "Log.S.AllGrp", # Labels
xlab = VarUse, # Labels
pch=19)  # Point type
# add a smoother trend line using lowess
lines(lowess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse]),# Predictor
lwd = 2, # Line width
lty = 2, # Dashed line
col = "red")  # colour of the line
}
owess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse])
lowess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse])
lowless(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse])
?lowess
loess(y = residuals(DK.Biodiv.lm), # Residuals
x = DK.Biodiv[,VarUse])
loess(residuals(DK.Biodiv.lm) ~ DK.Biodiv[,VarUse]
)
summary(loess(residuals(DK.Biodiv.lm) ~ DK.Biodiv[,VarUse]))
dir("Data")
DK.Map <- read.rds("Data/gadm36_DNK_0_sp.rds")
DK.Map <- readRDS("Data/gadm36_DNK_0_sp.rds")
DK.Map <- spTransform(DK.Map, # object to be transformed
CRSobj = CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs") # New Projection
)
plot(DK.Map,add=T)
# Copy the data in `DK.Biodiv` into an object names `DK.Biodiv.Spatial`.
DK.Biodiv.Spatial <- DK.Biodiv # copy the original data
# Extract the standardized residuals of the `DK.Biodiv.lm` object
DK.Biodiv.Spatial$Resid <- rstandard(model = DK.Biodiv.lm) # Model to extract the residuals
# Transform the `DK.Biodiv.Spatial` to a `SpatialPointsDataframe`
coordinates(DK.Biodiv.Spatial) <- ~decimalLongitude+decimalLatitude
# Define the right reference system to `DK.Biodiv.Spatial`.
proj4string(DK.Biodiv.Spatial) <- CRS("+proj=longlat") # The
# Re-project `DK.Biodiv.Spatial` to `UTM/ETRS89`.
DK.Biodiv.Spatial <- spTransform(DK.Biodiv.Spatial, # object to be transformed
CRSobj = CRS("+proj=utm +zone=32 +ellps=intl +towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs +type=crs")# New Projection
)
# Add the projected X and Y to the Data frame of the Spatial object
DK.Biodiv.Spatial$X <- coordinates(DK.Biodiv.Spatial)[,'decimalLongitude']
DK.Biodiv.Spatial$Y <- coordinates(DK.Biodiv.Spatial)[,'decimalLatitude']
data(wrld_simpl)
# Plot the spatial object you created
plot(DK.Biodiv.Spatial,
pch=19)
bubble(DK.Biodiv.Spatial,
"Resid",
panel=function(...) {
sp:::panel.bubble(...)
sp.polygons(DK.Map, fill="NA")
})
dev.new()
bubble(DK.Biodiv.Spatial,
"Resid",
panel=function(...) {
sp:::panel.bubble(...)
sp.polygons(DK.Map, fill="NA")
})
?Variogram
