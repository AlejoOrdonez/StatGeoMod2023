nugget = TRUE),
method = "REML")
# Build a model with a Gaussian correlation structure.
Gaus.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corGaus(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
# Build a model with a Linear correlation structure.
Lin.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corLin(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
# Build a model with a Rational quadratic correlation structure. function.
Ratio.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corRatio(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
# Build a model with a Spherical correlation structure.
Spher.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corSpher(form = ~ LONG + LAT, # define the correlation structure
nugget = TRUE),
method = "REML")
Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
method = "REML")
Exp.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corExp(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
Gaus.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corGaus(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
Lin.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corLin(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
Ratio.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corRatio(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
Spher.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corSpher(form = ~ LONG + LAT, # define the correlation structure
nugget = TRUE),
method = "REML")
Spher.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corSpher(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
AICsumm <- AIC(Clim.Only_gls, # No correlation
Exp.Clim.Only_gls, # Exponential
Gaus.Clim.Only_gls, # Gaussian
Lin.Clim.Only_gls, # Linear
Ratio.Clim.Only_gls, # Ratio
Spher.Clim.Only_gls) # Spherical
rownames(AICsumm) <- c("NoCor", "Exponential", "Gaussian", "Linear", "Rational", "Spherical")
AICsumm
Ratio.Clim.Only_gls
corRatio(5e5,form = ~X+Y)
corRatio(form = ~X+Y,nuget=T)
corRatio(form = ~X+Y,nugget=T)
ls()
Initialize(corRatio(form = ~X+Y,nugget=T),paruelo_df)
Variogram(Initialize(corRatio(form = ~X+Y,nugget=T),paruelo_df))
plot(Variogram(Initialize(corRatio(form = ~X+Y,nugget=T),paruelo_df)))
str(Ratio.Clim.Only_gls)
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T)
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T)
Ratio.Vario.gls
plot(Ratio.Vario.gls[,2:1])
plot(Ratio.Vario.gls)
str(Ratio.Vario.gls)
as.data.frame(Ratio.Vario.gls)
plot(as.data.frame(Ratio.Vario.gls)[,2:1])
plot(as.data.frame(Ratio.Vario.gls)[,2:1])
plot(Ratio.Vario.gls, smooth = T)
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T)
?variogram
residuals(Ratio.Vario.gls,"normalized")
Ratio.Vario.gls
a <- residuals(Ratio.Clim.Only_gls,"normalized")
a
variogram(a, data = paruelo_df)
b <- variogram(a~1, data = paruelo_df)
d<- paruelo_df
coordinates(paruelo_df) <- ~X+Y
b <- variogram(a~1, data = paruelo_df)
plot(b)
plot(b,vgm(psill=0.15, model="Gau", nugget=0.0001, range=5))
Ratio.Clim.Only_gls
str(+)
str(Ratio.Clim.Only_gls)
plot(b,vgm(psill=1000000, model="Gau", nugget=0.0001, range=5))
plot(b,vgm(psill=600000, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=600000, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=0.15, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=6000000, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=6000000, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=6000000, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=6000000, model="Gau", nugget=0.0001, range=5))
fit.variogram(b,vgm(psill=6000000, model="Gau", nugget=0.0001, range=5))
paruelo_df <- read.csv(file = "Data/paruelo.csv")
plot(Ratio.Vario.gls, smooth = T)
fm1 <- lme(follicles ~ sin(2*pi*Time) + cos(2*pi*Time), Ovary)
plot(Variogram(fm1, form = ~ Time | Mare, maxDist = 0.7))
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
plot(Ratio.Vario.gls, smooth = T)
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T)
Ratio.Vario.gls
range(Ratio.Vario.gls)
Ratio.Vario.gls[,1]
range(Ratio.Vario.gls[,1])
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
range(Vario.gls[,1])
plot(Ratio.Vario.gls, smooth = T,ylim = c(0.4,1.6))
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6))
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,100e3))
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,100e4))
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,100e5))
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,100e4))
plot(Ratio.Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,100e4))
plot(Ratio.Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,150e4))
# Estimate the variogram of the of climate-only model residuals, setting the max lag distance to 10, and using normalized residuals.
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,150e4))
plot(Ratio.Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,150e4))
plot(Ratio.Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,120e4))
plot(Vario.gls, smooth = T, ylim = c(0.4,1.6), xlim = c(0,120e4))
rm(list=ls())
paruelo_df <- read.csv(file = "Data/paruelo.csv")
Clim.Only_lm <- lm(LC4 ~ MAT + MAP + JJAMAP + DJFMAP,
data = paruelo_df)
# Use the vif() function of the car package to estimate the tolerances (1/vif)
1/car::vif(Clim.Only_lm)
# Evaluate  the homogeneity of variances, and normality of residuals assumption
par(mfrow= c(2,2)) # set a 2x2 parameter space
# plot the `Clim.Only_lm` object
plot(Clim.Only_lm)
summary(Clim.Only_lm)$r.squared
# Climatic predictor model
Clim.Only_lm <- lm(LC4 ~ MAP + MAT + JJAMAP + DJFMAP,
data = paruelo_df)
# Call the summary of Clim.Only_lm
summary(Clim.Only_lm)
# Spatial predictors model
Spatial.Only_lm <- lm(LC4 ~ X + Y,
data = paruelo_df)
# Call the summary of Spatial.Only_lm
summary(Spatial.Only_lm)
PosDtFrm <- data.frame(x = runif(100),
y = runif(100),
z = rpois(100, lambda = 10))
## weights w[i,j] = 1/d[i,j]:
Inv.Distance <- 1/as.matrix(dist(PosDtFrm))
## set the diagonal w[i,i] = 0 (instead of Inf...):
diag(Inv.Distance) <- 0
# Moran I
Moran.I(x = PosDtFrm$z,
w = Inv.Distance)
parueloDist <- dist(paruelo_df[ , c("X", "Y")]) # implement the function of a data.frame with only Longitude and latitude.
# Estimate the inverse of the matrix values (the weighted matrix).
parueloInvDist <- 1 / parueloDist
# Transform the parueloInvDist object from a distance object to a matrix using the as.matrix() function.
parueloInvDist <- as.matrix(parueloInvDist)
# Replace the diagonal entries with zero.
diag(parueloInvDist) <- 0
# You have created a matrix where each off-diagonal entry [*i* ,  *j*] in the matrix equals 1/(distance between point *i* and point *j*). Now use it to estimate Moran's I.
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the data on Log-transformed relative abundances of c4 grasses.
weight = parueloInvDist)
parueloDist <- dist(paruelo_df[ , c("LONG", "LAT")]) # implement the function of a data.frame with only Longitude and latitude.
# Estimate the inverse of the matrix values (the weighted matrix).
parueloInvDist <- 1 / parueloDist
# Transform the parueloInvDist object from a distance object to a matrix using the as.matrix() function.
parueloInvDist <- as.matrix(parueloInvDist)
# Replace the diagonal entries with zero.
diag(parueloInvDist) <- 0
# You have created a matrix where each off-diagonal entry [*i* ,  *j*] in the matrix equals 1/(distance between point *i* and point *j*). Now use it to estimate Moran's I.
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the data on Log-transformed relative abundances of c4 grasses.
weight = parueloInvDist) #
parueloDist <- dist(paruelo_df[ , c("LONG", "LAT")]) # implement the function of a data.frame with only
parueloInvDist <- 1 / parueloDist
parueloInvDist <- as.matrix(parueloInvDist)
diag(parueloInvDist) <- 0
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the data on Log-transformed relative abundances of c4 grasses.
weight = parueloInvDist) #  The matrix of weighted distances
parueloInvDist
rstandard(Clim.Only_lm)
parueloInvDist
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist)
parueloDist <- dist(paruelo_df[ , c("X", "Y")]) # implement the function of a data.frame with only Longitude and latitude.
# Estimate the inverse of the matrix values (the weighted matrix).
parueloInvDist <- 1 / parueloDist
# Transform the parueloInvDist object from a distance object to a matrix using the as.matrix() function.
parueloInvDist <- as.matrix(parueloInvDist)
# Replace the diagonal entries with zero.
diag(parueloInvDist) <- 0
# You have created a matrix where each off-diagonal entry [*i* ,  *j*] in the matrix equals 1/(distance between point *i* and point *j*). Now use it to estimate Moran's I.
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist)
parueloDist <- dist(paruelo_df[ , c("LONG", "LAT")]) # implement the function of a data.frame with only Longitude and latitude.
# Estimate the inverse of the matrix values (the weighted matrix).
parueloInvDist <- 1 / parueloDist
hist(parueloInvDist)
hist(log10(parueloInvDist))
parueloInvDist <- as.matrix(parueloInvDist)
diag(parueloInvDist) <- 0
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist) #  The matrix of weighted distances
?Moran.I
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist,
na.rm = T)
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist, scaled=T)
require(aperm())
require(ape)
rstandard(Clim.Only_lm)
ape::Moran.I(x = as.vector(rstandard(Clim.Only_lm)), # A vector with the standarized residuals.
weight = parueloInvDist, scaled=T) #  The matrix of weighted distances
parueloDist <- dist(paruelo_df[ , c("LONG", "LAT")]) # implement the function of a data.frame with only Longitude and latitude.
# Estimate the inverse of the matrix values (the weighted matrix).
parueloInvDist <- 1 / parueloDist
# Transform the parueloInvDist object from a distance object to a matrix using the as.matrix() function.
parueloInvDist <- as.matrix(parueloInvDist)
# Replace the diagonal entries with zero.
diag(parueloInvDist) <- 0
# You have created a matrix where each off-diagonal entry [*i* ,  *j*] in the matrix equals 1/(distance between point *i* and point *j*). Now use it to estimate Moran's I.
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist)
parueloDist <- dist(paruelo_df[ , c("X", "Y")]) # implement the function of a data.frame with only Longitude and latitude.
# Estimate the inverse of the matrix values (the weighted matrix).
parueloInvDist <- 1 / parueloDist
# Transform the parueloInvDist object from a distance object to a matrix using the as.matrix() function.
parueloInvDist <- as.matrix(parueloInvDist)
# Replace the diagonal entries with zero.
diag(parueloInvDist) <- 0
# You have created a matrix where each off-diagonal entry [*i* ,  *j*] in the matrix equals 1/(distance between point *i* and point *j*). Now use it to estimate Moran's I.
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist)
paruelo_df$X
parueloDist <- dist(paruelo_df[ , c("X", "Y")]/1000) # implement the function of a data.frame with only
parueloInvDist <- 1 / parueloDist
# Transform the parueloInvDist object from a distance object to a matrix using the as.matrix() function.
parueloInvDist <- as.matrix(parueloInvDist)
# Replace the diagonal entries with zero.
diag(parueloInvDist) <- 0
# You have created a matrix where each off-diagonal entry [*i* ,  *j*] in the matrix equals 1/(distance between point *i* and point *j*). Now use it to estimate Moran's I.
ape::Moran.I(x = rstandard(Clim.Only_lm), # A vector with the standarized residuals.
weight = parueloInvDist) #  The matrix of weighted distances
ClimStdRes <- rstandard(Clim.Only_lm)
# Plot the standardised residuals in space using X to determine the x-positions and Y to define the y - positions.
# The size of the bobble is based on the residuals magnitude, and the colour is based on the residuals sign (Red for negative - blue for positive)
plot(x = paruelo_df$X, # the X-coordinates (Longitude)
y = paruelo_df$Y, # the Y-coordinates (Latitude)
pch = 19, # make the point full
col = ifelse(ClimStdRes>0, # Logical test to determine if the Residual is positive or negative
"blue", # if positive then colour blue
"red"), # if negative then colour red
cex = 1.5*abs(ClimStdRes), # rescale the size
xlab = "X-coordinates", # X-axis name
ylab = "Y-coordinates", # Y-axis name
main = "Residuals" # Figure name
)
# Add a legend on the top-right position of the plot, that indicates the colour-size relation - Use 10 levies (5 for the positive and 5 for the Negative).
legend("topright", # position
pch = 19, # make the points full
col = c(rep("grey",5),# set the negative colours
"white",
rep("black",5)),# set the positive colours
pt.cex = 1.5*abs(seq(-2.5,2.5,by=0.5)), # set the point size for the positive/negative values
legend = seq(-2.5,2.5,by=0.5) # Range of positive/negative values
)
legend("topright", # position
pch = 19, # make the points full
col = c(rep("blue",5),# set the negative colours
"white",
rep("red",5)),# set the positive colours
pt.cex = 1.5*abs(seq(-2.5,2.5,by=0.5)), # set the point size for the positive/negative values
legend = seq(-2.5,2.5,by=0.5) # Range of positive/negative values
)
paruelo_df$X <- paruelo_df$X/1000
paruelo_df$Y <- paruelo_df$Y/1000
Clim.Only_gls <- gls(formula(Clim.Only_lm), # Get the Formula form the LM model
data = paruelo_df, # The data.frame with the variables
method ="REML") # The inference method
# Build a spatial correlograms
paruelo.Vargrm <- Variogram(Clim.Only_gls, # The gls model
form = ~ X + Y, # the way correlation is defined - here as
resType = "normalized", # the type of residuals to use
data = paruelo_df) # The data.frame with the variables
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0.4,1.6), xlim = c(0,120e4) # Set limits to the plot space (Semivarainces at extremely large
)
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0.4,1.6), xlim = c(0,1200) # Set limits to the plot space (Semivarainces at extremely large distances do not make sense)
)
?Variogram
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
maxDist = 120,
ylim = c(0.4,1.6) # Set limits to the plot space (Semivarainces at extremely large distances do not make sense)
)
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0.4,1.6) # Set limits to the plot space (Semivarainces at extremely large distances do not make sense)
)
?xyplot
paruelo.Vargrm <- Variogram(Clim.Only_gls, # The gls model
form = ~ X + Y, # the way correlation is defined - here as
resType = "normalized", # the type of residuals to use
maxDist = 120,
data = paruelo_df) # The data.frame with the variables
# Plot the semi-variogram
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0.4,1.6) # Set limits to the plot space (Semivarainces at extremely large distances do not make sense)
)
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T)
paruelo.Vargrm
paruelo.Vargrm <- Variogram(Clim.Only_gls, # The gls model
form = ~ X + Y, # the way correlation is defined - here as
resType = "normalized", # the type of residuals to use
maxDist = 200,
data = paruelo_df) # The data.frame with the variables
# Plot the semi-variogram
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T)
rabnge(paruelo.Vargrm[,1])
range(paruelo.Vargrm[,1])
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0.04,1.6) #
)
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0,1.6) #
)
paruelo.Vargrm <- Variogram(Clim.Only_gls, # The gls model
form = ~ X + Y, # the way correlation is defined - here as
resType = "normalized", # the type of residuals to use
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df) # The data.frame with the variables
# Plot the semi-variogram
plot(paruelo.Vargrm, # Define the Variogram object
smooth = T, # Add a trend line?
ylim = c(0,1.6) #
)
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df
)
Ratio.Clim.Only_gls <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corRatio(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "REML")
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df
)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T, ylim = c(0,1.6))
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T, ylim = c(0,1.6))
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T, ylim = c(0,1.6))
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df
)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T, ylim = c(0,1.6))
# Estimate the variogram of the of climate-only model residuals, setting the max lag distance to 10, and using normalized residuals.
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T, ylim = c(0,1.6))
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df
)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T, ylim = c(0,1.6))
# Refit the model with the best correlation structure as a gls using the method = "ML"
Ratio.Clim.Only_gls.ML <- gls(LC4 ~ MAP + MAT + JJAMAP + DJFMAP, # formula
data = paruelo_df, # Object with the data
correlation = corRatio(form = ~ X + Y, # define the correlation structure
nugget = TRUE),
method = "ML" # Specify that the model is fitted using ML
)
# Use the function `stepAIC()` from the package `MASS` to do the model section.
Ratio.Clim.Only_gls.Final <- stepAIC(Ratio.Clim.Only_gls.ML,
trace = 0)
# Call the summary of the final model
summary(Ratio.Clim.Only_gls.Final)
Ratio.Clim.Only_gls.Final <- update(Ratio.Clim.Only_gls.Final, method = "REML")
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls.Final, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T,ylim = c(0,1.6) # Set limits to the plot space (Semivarainces at extremely
)
Ratio.Clim.Only_gls.Final
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls.Final, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 200,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T,ylim = c(0,1.6) # Set limits to the plot space (Semivarainces at extremely large distances do not make sense)
)
plot(Vario.gls, smooth = T, ylim = c(0,1.6))
Vario.gls <- Variogram(Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 1000,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df)
# plot the variogram with a smoothed line
plot(Vario.gls, smooth = T, ylim = c(0,1.6))
Ratio.Vario.gls <- Variogram(Ratio.Clim.Only_gls, # a gls model
form = ~ X + Y, # define the source of the spatial data
resType = "normalized", # define the type of residuals
maxDist = 1000,  #Set limits to the Semi-variagram space (Semivarainces at extremely large distances do not make sense)
data = paruelo_df
)
# plot the variogram with a smoothed line
plot(Ratio.Vario.gls, smooth = T, ylim = c(0,1.6))
vignette("gradethis")
remotes::install_github("rstudio/learnr")
install.packages(c("devtools", "car", "ape", "nlme", "lme4", "sp", "MASS", "learnr"))
remotes::install_github("rstudio/gradethis")
ieno <- read.csv("https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/Biodiversity.csv")
ColPlot <- ifelse(ieno$Treatment=="Algae", # set the colours using Treatment
"red", "blue" # red = algae
)
# Use the coplot() function to evaluate how `Concentration` changes as a function of `Biomass` and `Nutrient
coplot(Concentration ~ Biomass | Nutrient, #
data = ieno, # Specify the name of the object where the data can be found
columns = 3, # Number of columns in the panel layout array
pch = 19, # Make the points filled circles
col = ColPlot # set the colours using Treatment
)
